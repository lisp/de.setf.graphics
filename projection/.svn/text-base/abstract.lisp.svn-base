;;; -*- Mode: LISP; Syntax: Common-lisp; Package: de.setf.object-graphics.implementation; Base: 10; Lowercase: Yes -*-

<DOCUMENTATION>
 <title>abstract peojection</title>
 <DESCRIPTION>
  abstract interface for graphic projection functions.
  <p>
  defines abstract functions for rendering operations. these expect to be exectuted in a dynamic interface context, within which the concrete operation implementations are bound. if no binding is found for a given operation, it is ignored.</p>
  </DESCRIPTION>
 <CHRONOLOGY>
  <DELTA DATE='20030905' AUTHOR='james.anderson@setf.de' />
  </CHRONOLOGY>
 </DOCUMENTATION>

(in-package :de.setf.object-graphics.implementation)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (error "this is obsolete. see abstract-projection.lisp"))

(deftype aspect-specification () '(or sequence function))


(defun no-op (&rest args)
  (declare (dynamic-extent args)
           (ignore args))
  nil)

(defParameter .og.::*verbose* t
  "when non-null a warning is printed for functions with no applicable methods.")

(defParameter *projection-context* nil)

(defparameter *projection-aspects* (make-array 0 :adjustable t :fill-pointer t)
  "a fill fector which binds the names of the state aspects. this is used to map names to positions in the flags which indicate which aspects are to be saved in a given context before modification.")

(defparameter *projection-aspect-stack* (make-array 0 :adjustable t :fill-pointer t)
  "a vector stack onto which restore operations are pushed. each 'frame' comprises a sequence of spread forms followed by an element count. a count of zero indicates the end of the frame.")

(defparameter *all-projection-aspects* -1)

(defparameter *no-projection-aspects* 0)

(defparameter *modified-aspects* *all-projection-aspects*
  "binds a flag set to indicate which aspects have been modified in a given dynamic context. the static value is *all-projection-aspects*, which indicates that no aspects are saved prior to modification. when a context is entered the value is rebound to ~*dynamic-aspects* whichcauses any initial modification to cache the aspect for resoration when the context completes.")

(defparameter *dynamic-aspects* *all-projection-aspects*
  "binds a flag set which indicates which aspects are to be protected in a given context. upon entry to a context *modified-aspects* is bound to ~*dynamic-aspects*." )

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defVar +.og.package+ (find-package :.og.)))

(defParameter *context-view* nil)

(defParameter *context-default-z* 0.0d0
  "used as the default z value fo 2d coordinates")

(defParameter *context-default-alpha* 1.0s0
  "used as the default alpha value")

(defParameter *context-zero* 0.0d0)
(defParameter *context-one* 1.0d0)

(defParameter *context-ink* nil
  "binds the current effective drawing color for the active context. may combine the active color with belnding and/or inversion effects")

(defParameter *context-fill-agent* nil
  "binds the current fill instance for the active context.")
(defParameter *context-mark-agent* nil
  "binds the current stroke instance for the active context.")
(defParameter *context-empty-agent* nil
  "binds the current background color for the active context.")

(defParameter *context-path-effect* :paint
  "binds the current effect (paint, erase, invert) for the active context.")
(defParameter *context-path-constituents* :lines
  "binds the current path mode (fill, stroke, points) for the active context.")
(defParameter *context-path-rule* :winding
  "binds the current path rule (winding, even-odd) for the active context.")

(defParameter *path-constituents* '(:surfaces :lines :points
                                    :lines/lines :lines/surfaces :lines/points
                                    :points/lines :points/surfaces :points/points
                                    :surfaces/lines :surfaces/surfaces :surfaces/points))
(defparameter *single-sided-constituents* '(:lines :surfaces :points))
(defparameter *double-sided-constituents* '(:lines/lines :lines/surfaces :lines/points
                                            :points/lines :points/surfaces :points/points 
                                            :surfaces/lines :surfaces/surfaces :surfaces/points))
(defParameter *double-to-single-sided-map* '((:lines/lines . :lines) (:lines/surfaces . :lines) (:lines/points . :lines)
                                             (:points/lines . :lines) (:points/surfaces . :surfaces) (:points/points . :points)
                                             (:surfaces/lines . :surfaces) (:surfaces/surfaces . :surfaces) (:surfaces/points . :surfaces)))
(defParameter *single-to-double-sided-map* '((:lines . :lines/lines)  
                                             (:points . :points/points)
                                             (:surfaces . :surfaces/surfaces)))
(defParameter *path-rules* '(:winding :even-odd))
(defParameter *path-effects* '(:erase :paint :flip))
(defParameter *path-agents* '(:fill :empty :mark))
(defParameter *path-rules* '(:even-odd :winding))
(defParameter *blend-factors* '(:src-alpha :one-minus-src-alpha))

(defParameter *context-drawing-mode* nil
  "binds the current composite drawing mode for the active context. any aspect note presented is taken from the current constituent value. default: nil.")

;;;
;;; caching support

(defClass caching-context ()
  ((name
    :initform (gensym "CONTEXT-") :initarg :name
    :reader context-name
    :documentation
    "binds a name for use to associate the context with things in its own cache.")
   (cache
    :initform (make-hash-table :test 'equalp)))
  (:documentation
   "a caching-context adds a hash table to a context. it supports the accessor context-get, which retrieves or caches a value according to owner and id keys."))

(defGeneric context-get (context owner id)
  (:documentation
   "retrieve a value from a given context as named by the combined argument owner and id keys.")
  (:method ((context caching-context) owner id)
           (let ((key (cons owner id)))
             (declare (dynamic-extent key))
             (with-slots (cache) context (gethash key cache)))))

(defGeneric terminate-relation (owner relation owned)
  (:documentation
   "this is called when some owner instance is either directly terminated, or some context of its use is terminated and the owned instance is no longer to be used. for example, when a projection context is terminated, all projections can be terminated.")
  (:method ((owner t) (relation t) (owned t))
           (warn "anamolous termination: ~s ~s ~s." owner relation owned))
  (:method ((owner null) (relation t) (owned t))
           ;; anonymous items are ignored
           ))

(defGeneric (setf context-get) (value context owner id)
  (:documentation
   "cache a value in a given context as named by the combined argument owner and id keys. a new combined key is constructed with the argument owner and id. for any non-elementary values, a termination function is registered, which when called delegates to (terminate-relation owner id value). ")
  (:method (value (context caching-context) owner id)
           (with-slots (cache) context
             ;; use the argument value, otherwise the original value remains reachable
             (unless (or (null owner) (numberp value) (characterp value))
               #+digitool
               (terminate-when-unreachable value
                                           #'(lambda (v) (terminate-relation owner id v))))
             (setf (gethash (cons owner id) cache) value))))

(defGeneric terminate-context (context)
  (:documentation
   "called when a context is no longer reachable to dispose of any static resources.
    asserted by an after method on initialize-instance")
  (:method ((context caching-context))
           "the general method does nothing"))

(defMethod initialize-instance :after ((instance caching-context) &key)
  #+digitool (terminate-when-unreachable instance #'terminate-context)
  )

(defclass projection-context ()
  ())

(defClass view-context (projection-context)
  ((view
    :initarg :view
    :accessor context-view
    :documentation
    "binds the view or drawable into which the context projects."))
  (:documentation
   "binds a view for the context"))

(defClass aspect-context (projection-context)
  ()
  (:documentation
   "enables aspect saving and restoring"))

(defClass single-sided-aspect-context (aspect-context)
  ()
  (:documentation
   "enables aspect saving and restoring"))

(defClass double-sided-aspect-context (aspect-context)
  ()
  (:documentation
   "enables aspect saving and restoring"))

(defClass delegate-context ()
  ()
  (:documentation
   "a marker for classes which implement the abstract interface by delegation. for each interface function includes a method is generated for this classto delegate to the result of applying #'effective-context to the argument"))

(defGeneric effective-context (delegate-context)
  (:documentation
   "concrete delegates must implement a method of one argument, the delegate, which returns the effective context."))

;;;
;;;

(defMacro with-short-float-intensity-variables (variables &rest body)
  `(progn ,@(mapcar #'(lambda (var)
                        `(etypecase ,var
                           (short-float)
                           (double-float (setf ,var (float ,var 1.0s0)))
                           (integer (setf ,var (/ ,var 65535.0s0)))
                           (number (setf ,var (float ,var 1.0s0)))))
                    variables)
          (locally (declare (type short-float ,@variables)))
          ,@body))

(defMacro with-fixnum-intensity-variables (variables &rest body)
  `(progn ,@(mapcar #'(lambda (var)
                        `(unless (integerp ,var) (setf ,var (round (* ,var 65535.0d0)))))
                    variables)
          (locally (declare (type fixnum ,@variables)))
          ,@body))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun boa-argument-list (lambda-list)
    "extract the required, optional and rest or keywords arguments from a lambda list for use in a macro which generates mediating functions. returns two values, the list of arguments and a boolean to indicate if the last argument binds a rest value."
    (let ((aux-p nil) (rest-arg nil) (key-p nil) (optional-p nil))
      (values
       (reduce #'append
               (mapcar #'(lambda (parameter)
                           (flet ((parameter-argument (parameter)
                                    (cond (optional-p (list parameter))
                                          (rest-arg (if (eq rest-arg t)
                                                      (list (setf rest-arg parameter))
                                                      (list parameter)))
                                          (key-p (unless rest-arg
                                                   (list (if (consp parameter)
                                                           (first parameter)
                                                           (intern (string parameter) :keyword))
                                                         parameter)))
                                          (aux-p nil)
                                          (t (list parameter)))))
                             (etypecase parameter
                               (cons (parameter-argument (first parameter)))
                               (symbol (case parameter
                                         (&optional (setf optional-p t) nil)
                                         (&rest (setf rest-arg t) nil)
                                         (&key (setf key-p t) nil)
                                         (&aux (setf aux-p t) nil)
                                         (t (parameter-argument parameter)))))))
                       lambda-list))
       rest-arg))))

(defmacro defProjectionAspect (name)
  (let ((bit-variable (intern (concatenate 'string #.(string :+projection-state-) (string name) #.(string :-bit+))))
        (mask-variable (intern (concatenate 'string #.(string :+projection-state-) (string name) #.(string :-mask+)))))
    `(progn
       (defparameter ,bit-variable (or (position ',name *projection-aspects*)
                                       (vector-push-extend ',name *projection-aspects*)))
       (defparameter ,mask-variable (ash 1 ,bit-variable))
       (defProjectionOp ,(intern (concatenate 'string #.(string :save-) (string name))) ()
         (:method ((context delegate-context)) nil)))))

(defMacro defProjectionOp (name lambda-list &rest options)
  "define a delegating projection operation. the definition comprises a special variable which binds the implementation function for the current projection and an interface function, which delegates to the implementation with an argument list augmented by the value of *projection-context*. the function body permits a documentation string, a sequence of declarations, and a series of clauses, each of which specifies a projection type. "
  (labels ((arg1-specializer (method)
             (destructuring-bind (((param specializer) &rest rest) &rest body)
                                 (nthcdr (or (position-if (complement #'symbolp) method)
                                             (error "invalid method clause: ~s." method))
                                         method)
               (declare (ignore param rest body))
               specializer))
           (find-specialized-method (specializer methods)
             (dolist (m methods)
               (when (and (listp (second m))
                          (equal specializer (arg1-specializer m)))
                 (return m)))))
    (let* ((methods (remove :method options :key #'first :test (complement #'eq)))
           (specialization-variable (assoc :specialization-variable options))
           (delegation-accessor (assoc :delegation-accessor options))
           (documentation (assoc :documentation options))
           (gf-name (intern (string name) +.og.package+))
           (list-operator 'list)
           (call-operator 'funcall)
           (specialization-parameter (gensym "CONTEXT-")))
      (multiple-value-bind (arguments rest-arg) (boa-argument-list lambda-list)

        (when rest-arg (setf list-operator 'list* call-operator 'apply))
        (setf options (set-difference options methods))
        (if specialization-variable
          (setf options (remove specialization-variable options)
                specialization-variable (second specialization-variable))
          (setf specialization-variable '*projection-context*))
        (if delegation-accessor
          (setf options (remove delegation-accessor options)
                delegation-accessor (second delegation-accessor))
          (setf delegation-accessor 'effective-context))
        
        (unless (find-specialized-method '(eql t) methods)
          (push `(:method ((,specialization-parameter (eql t)) ,@lambda-list)
                          (,list-operator ',name ,@arguments))
                methods))
        (unless (find-specialized-method 't methods)
          (push `(:method ((,specialization-parameter t) ,@lambda-list)
                          (when .og.::*verbose*
                            (warn "no method method for operation: ~s: ~s." ',name (,list-operator ,@arguments))))
                methods))
        (unless (find-specialized-method 'null methods)
          (push `(:method ((,specialization-parameter null) ,@lambda-list)
                          (declare (ignore ,@arguments))
                          nil)
                methods))
        (unless (find-specialized-method 'function methods)
          (push `(:method ((,specialization-parameter function) ,@lambda-list)
                          (,call-operator ,specialization-parameter ',name ,@arguments))
                methods))
        (unless (find-specialized-method 'delegate-context methods)
          (push `(:method ((,specialization-parameter delegate-context) ,@lambda-list)
                          (,call-operator #',gf-name (,delegation-accessor ,specialization-parameter) ,@arguments))
                methods))
        `(progn (defGeneric ,gf-name ,(cons 'context lambda-list)
                  ,@methods
                  ,@options)
                (defun ,name ,lambda-list
                  ,@(when documentation (rest documentation))
                  ,@(when rest-arg `((declare (dynamic-extent ,rest-arg))))
                  (,call-operator #',gf-name ,specialization-variable ,@arguments)))))))


(defmacro defProjectionAspectOp (name lambda-list &rest options)
  "generate a save method for the aspect. by default generate a no-op for delegates."
  (flet ((arg1-specializer (method)
           (destructuring-bind (((param specializer) &rest rest) &rest body)
                               (nthcdr (or (position-if (complement #'symbolp) method)
                                           (error "invalid method clause: ~s." method))
                                       method)
             (declare (ignore param rest body))
             specializer)))
    (multiple-value-bind (arguments rest-arg) (boa-argument-list lambda-list)
      (declare (ignore rest-arg))
      (unless (find-if #'(lambda (clause)
                           (and (eq (second clause) :before)
                                (eq (arg1-specializer clause) 'context-with-aspects)))
                       options)
        (let ((mask-variable (intern (concatenate 'string #.(string :+projection-state-) (string name) #.(string :-mask+)))))
          (push `(:method :before ,(cons '(context t) lambda-list)
                          (declare (ignore ,@arguments))
                          (when (zerop (logand ,mask-variable *modified-aspects*))
                            (setf *modified-aspects* (logior ,mask-variable *modified-aspects*))
                            (,(intern (concatenate 'string #.(string :save-) (string name))))))
                options))))
    `(defProjectionOp ,name ,lambda-list ,@options)))

(defGeneric call-with-projection-context (function context &key &allow-other-keys)
  (:documentation
   "call argument function in the context of a given graphic interface.
    the base method binds the function parameters for simple geometric operations.")
  (:argument-precedence-order context function)
  (:method ((function function) (*projection-context* t) &key &allow-other-keys)
           "the general method binds the *projection-context* variable and applies the function to the argument value."
           (funcall function *projection-context*))
  (:method ((function t) (context view-context) &key &allow-other-keys)
           (let ((*context-view* (context-view context)))
             (call-next-method)))
  (:method ((function t) (context delegate-context) &rest args)
           (declare (dynamic-extent args))
           (apply #'call-next-method (effective-context context) args)))
         

(defMacro with-projection-context ((&optional context &rest args) &rest body &environment env)
  (let ((context-variable (if (and context (symbolp context) (eq context (macroexpand context env)))
                            context
                            (gensym "CONTEXT-")))
        (function (gensym "BODY-")))
    `(flet ((,function (,context-variable)
              #+ccl (declare (ccl::ignore-if-unused ,context-variable))
              ,@body))
       (declare (dynamic-extent #',function))
       (call-with-projection-context #',function ,context ,@args))))

(defmacro projection-list (&rest expressions)
  "collect the projection list results in a null context. this defers their side-effects"
  `(let ((*projection-context* nil))
     (list ,@expressions)))


(defun push-projection-context ()
  (vector-push-extend 0 *projection-aspect-stack*))

(defun push-projection-aspects (&rest form &aux (count 0))
  (declare (dynamic-extent form))
  (dolist (element form)
    (vector-push-extend element *projection-aspect-stack*)
    (incf count))
  (vector-push-extend count *projection-aspect-stack*))

(defun restore-display-state (&aux count)
  (labels ((pop-and-call (elements count)
             (cond ((> count 0)
                    (let ((elements (cons (vector-pop *projection-aspect-stack*) elements)))
                      (declare (dynamic-extent elements))
                      (pop-and-call elements (1- count))))
                   (elements
                    (apply (first elements) (rest elements))))))
    (when (> (length *projection-aspect-stack*) 0)
      (loop (setf count (vector-pop *projection-aspect-stack*))
            ;(break "restore-display-state: count: ~s" count)
            (when (zerop count) (return))
            (pop-and-call nil count)))))


(defmacro with-aspects ((&optional aspect-op &rest aspects) &rest body)
  (let ((dynamic-aspects nil))
    (loop (case aspect-op
            (:dynamic-aspects (setf dynamic-aspects (first aspects)))
            (t
             (if (keywordp aspect-op)
               (error "invalid aspect operator ~s." aspect-op)
               (return))))
          (destructuring-bind ((&optional new-aspect-op &rest new-aspects) &rest new-body) body
            (setf aspect-op new-aspect-op
                  aspects new-aspects
                  body new-body)))
    (let ((body-function-name (gensym "BODY-")))
      (if aspect-op
        (let ((aspect-function-name (gensym "ASPECTS-")))
          (cond ((eq aspect-op 'lambda )
                 `(flet ((,body-function-name () ,@body)
                         (,aspect-function-name ,@aspects))
                    (declare (dynamic-extent #',body-function-name #',aspect-function-name))
                    (call-with-aspects #',body-function-name #',aspect-function-name
                                       ,@(when dynamic-aspects `(:dynamic-aspects ,dynamic-aspects)))))
                ((eq aspect-op 'function)
                 `(flet ((,body-function-name () ,@body))
                    (declare (dynamic-extent #',body-function-name))
                    (call-with-aspects #',body-function-name (,aspect-op ,@aspects)
                                       ,@(when dynamic-aspects `(:dynamic-aspects ,dynamic-aspects)))))
                (t
                 (let ((body-arg-name (gensym)))
                   `(flet ((,body-function-name () ,@body)
                           (,aspect-function-name (,body-arg-name)
                             (progn ,(if (consp aspect-op) (list* 'progn aspect-op aspects) (cons aspect-op aspects))
                               (funcall ,body-arg-name))))
                      (declare (dynamic-extent #',body-function-name #',aspect-function-name))
                      (call-with-aspects #',body-function-name #',aspect-function-name
                                         ,@(when dynamic-aspects `(:dynamic-aspects ,dynamic-aspects))))))))
        `(flet ((,body-function-name () ,@body))
           (declare (dynamic-extent #',body-function-name))
           (call-with-aspects #',body-function-name ,(if dynamic-aspects '#'(lambda () ()) nil)
                              ,@(when dynamic-aspects `(:dynamic-aspects ,dynamic-aspects))))))))


(defgeneric call-with-aspects (op aspects &key dynamic-aspects)
  (:argument-precedence-order aspects op)
  (:documentation
   "execute an argument display operation 'in the context of' argument projection aspects. the display operation should be a function of no argument. the operation aspects may be a function of one argument, null, a sequence of aspects, or a lambda expression. if it is a sequence, the elements may be display operation expressions, function designators, graphic constituents, assignment expressions. the sequence may also be a single lambda expression, which binds the single argument to a function designator for the displa operation function.

display operations expressions are interpreted. function designators are called no argument, graphic constituents are provided as the single argument to a call to #'project. a symbol is evaluated and processing continues with that value. a number is assigned to the current save flags. the symbol t denotes a call to the argument function. if no t is present, then the argument function is called once after the list has been interpreted.")
  (:method ((op function) (aspects function) &key ((:dynamic-aspects *dynamic-aspects*) *dynamic-aspects*))
           (cond ((not (zerop *dynamic-aspects*))
                  (let ((*modified-aspects* (lognot *dynamic-aspects*))) 
                    (unwind-protect (progn (push-projection-context)
                                           (funcall aspects op))
                      (restore-display-state))))
                 (t
                  (funcall aspects op))))
  (:method ((op function) (aspects null) &key &allow-other-keys)
           (funcall op))
  (:method ((op t) (aspect-list sequence) &rest args &aux (function-binding nil))
           (declare (dynamic-extent args))
           (flet ((do-aspect (aspect)
                    (when (consp aspect)
                      (let ((aspect-op (first aspect))
                            (aspect-args (rest aspect)))
                        (case aspect-op
                          (setq (eval aspect-op))
                          (funcall (if (eq (first aspect-args) function-binding)
                                     (funcall op)
                                     (eval aspect)))
                          (t
                           (when (fboundp aspect-op)
                             (apply aspect-op aspect-args)
                             )))))))
             (declare (dynamic-extent #'do-aspect))
             (flet ((do-aspect-list (the-op)
                      (typecase aspect-list
                        (list (case (first aspect-list)
                                (lambda (destructuring-bind ((parm) . body) (rest aspect-list)
                                          (setf function-binding parm
                                                aspect-list body)))
                                (progn (pop aspect-list)))
                              (mapc #'do-aspect aspect-list)
                              (unless function-binding (funcall the-op)))
                        (vector (map nil #'do-aspect aspect-list)
                                (funcall the-op)))))
               (declare (dynamic-extent #'do-aspect-list))
               (apply #'call-with-aspects op #'do-aspect-list args)))))


(defGeneric aspect-p (context function)
  (:documentation
   "returns true if the argument function is specialized for the given context")
  (:method ((context t) (function symbol))
           (and (or (eq (symbol-package function) +.og.package+)
                    (setf function (find-symbol (symbol-name function) +.og.package+)))
                (fboundp function)
                (aspect-p context (fdefinition function))))
  (:method ((context t) (function t))
           nil)
  (:method ((context standard-object) (function generic-function))
           (flet ((method-qualifies? (method)
                    (let ((specializer (first (method-specializers method))))
                      (and (typep specializer 'class)
                           (not (eq t (class-name specializer)))
                           (typep context specializer)))))
             (declare (dynamic-extent #'method-qualifies?))
             (find-if #'method-qualifies? (generic-function-methods function)))))


;;
;; geometric object operators

(defProjectionOp arc (location radius start end direction &optional properties))
(defProjectionOp arc*2 (x y radius start end direction &optional properties))
(defProjectionOp arc*3 (x y z radius start end direction &optional properties))
(defun circle (location radius &optional properties)
  (arc location radius *context-zero* +2pi+ :clockwise properties))
(defun circle*2 (x y radius &optional properties)
  (arc*2 x y radius *context-zero* +2pi+ :clockwise properties))
(defun circle*3 (x y z radius &optional properties)
  (arc*3 x y z radius *context-zero* +2pi+ :clockwise properties))
(defProjectionOp line (l1 l2 &optional properties))
(defProjectionOp line*2 (x1 y1 x2 y2 &optional properties))
(defProjectionOp line*3 (x1 y1 z1 x2 y2 z2 &optional properties))
(defProjectionOp poly (vertices mode &optional properties))
(defProjectionOp raster (location size raster &optional properties))
(defProjectionOp raster*2 (x y w h raster &optional properties))
(defProjectionOp raster*3 (x y z w h d raster &optional properties))
(defProjectionOp rectangle (l1 l2 &optional properties))
(defProjectionOp rectangle*2 (x1 y1 x2 y2 &optional properties))
(defProjectionOp rectangle*3 (x1 y1 z1 x2 y2 z2 &optional properties))
(defProjectionOp text (location text font &optional properties))
(defProjectionOp text*2 (x y text font &optional properties))
(defProjectionOp text*3 (x y z text font &optional properties))

(defGeneric context-path-agent (context generic-agent)
  (:documentation
   "resolve the generic agent for the given projection context."))

(defun inflect-geometry (geometry-operator)
  (if *context-drawing-mode*
    (let* ((path-constituents nil)
           (path-effect nil)
           (path-rule nil)
           (path-agent nil)
           (modifications #x1000))
      (flet ((do-call ()
               (funcall geometry-operator
                        (if path-agent path-agent
                            (if (eq path-effect :erase) *context-empty-agent*
                                (if (eq path-constituents :surfaces)
                                  *context-fill-agent*
                                  *context-mark-agent*)))
                        (if path-constituents path-constituents *context-path-constituents*)
                        (if path-effect path-effect *context-path-effect*)
                        (if path-rule path-rule *context-path-rule*))
               (setf modifications 0)))
        (flet ((assert-property (property)
                 (case property
                   ;; rendering effects
                   ((:surfaces :lines :points)
                    (unless (eq path-constituents property)
                      (unless (zerop (logand modifications #x100)) (do-call))
                      (setf modifications (logior modifications #x100)
                            path-constituents property)))
                   ((:erase :flip :paint)
                    (unless (eq path-effect property)
                      (unless (zerop (logand modifications #x01)) (do-call))
                      (setf modifications (logior modifications #x001)
                            path-effect property)))
                   ((:winding :even-odd)
                    (unless (eq path-rule property)
                      (setf modifications (logior modifications #x010)
                            path-rule property)))
                   ((nil)
                    (do-call))
                   (t (setf path-agent (context-path-agent *projection-context* property))))))
          (etypecase *context-drawing-mode*
            (cons (dolist (property *context-drawing-mode*) (assert-property property)))
            (vector (dotimes (i (length *context-drawing-mode*))
                      (assert-property (aref *context-drawing-mode* i))))
            (null )
            (keyword (assert-property *context-drawing-mode*)))
          (unless (zerop modifications) (do-call)))))
    ;; w/o local inflections
    (funcall geometry-operator
             (if (eq *context-path-effect* :erase)
               *context-empty-agent*
               (if (eq *context-path-constituents* :surfaces)
                 *context-fill-agent*
                 *context-mark-agent*))
             *context-path-constituents*
             *context-path-effect*
             *context-path-rule*)))


;;;
;;; attributes

(defProjectionOp color*3 (r g b)
  (:method ((context t) r g b)
           "the general method returns a tagged list of the arguments."
           (list 'color*3 r g b)))
(defProjectionOp color*4 (r g b a)
  (:method ((context t) r g b a)
           "the general method returns a tagged list of the arguments."
           (list 'color*4 r g b a)))


(defProjectionAspect color-mode)
(defProjectionAspectOp color-mode (mode &rest args))

(defProjectionAspect drawing-mode)
(defProjectionAspectOp drawing-mode (mode))

(defProjectionAspect fill-agent)
(defProjectionAspectOp fill-agent (color &optional g b a))

(defProjectionAspect mark-agent)
(defProjectionAspectOp mark-agent (color &optional g b a))

(defProjectionAspect empty-agent)
(defProjectionAspectOp empty-agent (color &optional g b a))

(defun path-agent (agent-name &rest args)
  (declare (dynamic-extent args))
  (apply (ecase agent-name (:fill #'fill-agent) (:mark #'mark-agent) (:empty #'empty-agent))
         args))

(defProjectionAspect path-constituents)
(defProjectionAspectOp path-constituents (front))

(defProjectionAspect path-effect)
(defProjectionAspectOp path-effect (effect))

(defProjectionAspect path-rule)
(defProjectionAspectOp path-rule (rule))

(defun manifest (&rest args)
  (declare (dynamic-extent args))
  (loop (unless args (return))
        (setf args (do-manifestation (pop args) args))))

(defGeneric do-manifestation (option args)
  (:documentation
   "recognize  a manifestation aspect from an initial argument, extract the respective arguments and dispatch to the appropriate aspect operator.")
  (:method ((option cons) args)
           (path-constituents option)
           args)
  (:method ((option symbol) args)
           (flet ((call-with-subseq (function list &optional (length (if (keywordp (first list)) 1 (position-if #'symbolp args))))
                    (cond (length
                           (locally (declare (type fixnum length)
                                             (type cons list))
                             (let ((subseq (make-list length)))
                               (declare (dynamic-extent sub-args))
                               (mapl #'(lambda (from to) (setf (car to) (car from))) list subseq)
                               (setf list (nthcdr length list))
                               (funcall function subseq)
                               list)))
                          (t
                           (funcall function list)
                           nil))))
             (case option
               (:agent
                (call-with-subseq #'(lambda (sub-args) (apply #'path-agent (first args) sub-args)) (rest args)))
               (:constituents
                (path-constituents (pop args))
                args)
               (:effect
                (path-effect (pop args))
                args)
               (:rule
                (path-rule (pop args))
                args)
               (:blend
                (call-with-subseq #'(lambda (sub-args) (apply #'color-mode option sub-args))
                                  args
                                  (etypecase (first args)
                                    (number 1)
                                    (keyword 2)
                                    (null 0))))
               (t                         ; if it does not specify which aspect, look at the value
                (cond ((member option *path-agents*)
                       (flet ((set-agent (args) (apply #'path-agent option args)))
                         (declare (dynamic-extent #'set-agent))
                         (call-with-subseq #'set-agent args)))
                      ((member option *path-constituents*)
                       (path-constituents option)
                       args)
                      ((member option *path-effects*)
                       (path-effect option)
                       args)
                      ((member option *path-rules*)
                       (path-rule option)
                       args)
                      (t
                       (error "invalid maifestions: ~s . ~s"
                              option args))))))))


;;; 
;;; simple state management for single-sided aspect contexts


(defMethod .og.::path-constituents ((context single-sided-aspect-context) mode)
  (labels ((normalize-mode (mode)
             (or (etypecase mode
                   (keyword (or (find mode *single-sided-constituents*)
                                (rest (assoc mode *double-to-single-sided-map*))))
                   (string (or (find mode *single-sided-constituents* :test #'string-equal)
                               (rest (assoc mode *double-to-single-sided-map* :test #'string-equal))))
                   (symbol (when (and (boundp mode)
                                      (not (eq mode (setq mode (symbol-value mode)))))
                             (normalize-mode mode))))
                 (error "invalid path mode: ~s" mode))))
    (setq *context-path-constituents* (normalize-mode mode))))

(defMethod .og.::path-constituents ((context double-sided-aspect-context) mode)
  (labels ((normalize-mode (mode)
             (or (etypecase mode
                   (keyword (or (find mode *double-sided-constituents*)
                                (rest (assoc mode *single-to-double-sided-map*))))
                   (string (or (find mode *double-sided-constituents* :test #'string-equal)
                               (rest (assoc mode *single-to-double-sided-map* :test #'string-equal))))
                   (symbol (when (and (boundp mode)
                                      (not (eq mode (setq mode (symbol-value mode)))))
                             (normalize-mode mode))))
                 (error "invalid path mode: ~s" mode))))
    (setq *context-path-constituents* (normalize-mode mode))))

(defMethod .og.::save-path-constituents ((context aspect-context))
  (push-projection-aspects #'(lambda (saved-value) (setf  *context-path-constituents* saved-value)) *context-path-constituents*))

(defMethod .og.::path-rule ((context aspect-context) rule)
  (labels ((normalize-rule (rule)
             (or (etypecase rule
                   (keyword (find rule *path-rules*))
                   (string (find rule *path-rules* :test #'string-equal))
                   (symbol (when (and (boundp rule)
                                      (not (eq rule (setq rule (symbol-value rule)))))
                             (normalize-rule rule))))
                 (error "invalid path rule: ~s" rule))))
    (setq *context-path-rule* (normalize-rule rule))))

(defMethod .og.::save-path-rule ((context aspect-context))
  (push-projection-aspects #'(lambda (saved-rule) (setf  *context-path-rule* saved-rule)) *context-path-rule*))

(defMethod .og.::path-effect ((context aspect-context) effect)
  (labels ((normalize-effect (effect)
             (or (etypecase effect
                   (keyword (find effect *path-effects*))
                   (string (find effect *path-effects* :test #'string-equal))
                   (symbol (when (and (boundp effect)
                                      (not (eq effect (setq effect (symbol-value effect)))))
                             (normalize-effect effect))))
                 (error "invalid path effect: ~s" effect))))
    (setq *context-path-effect* (normalize-effect effect))))

(defMethod .og.::save-path-effect ((context aspect-context))
  (push-projection-aspects #'(lambda (saved-effect) (setf  *context-path-effect* saved-effect)) *context-path-effect*))


;;;
;;; coordinates

(defProjectionAspect projection-transform)
(defProjectionAspectOp projection-transform (op &rest parameters))

(defProjectionAspect view-transform)
(defProjectionAspectOp view-transform (op &rest parameters))


(defun transform (&rest args &aux target)
  (declare (dynamic-extent args))
  (flet ((do-transform (transformer)
           (let ((combination (pop args))
                 (arg-count (position-if #'keywordp args)))
             (if arg-count
               (locally (declare (type fixnum arg-count))
                 (let ((sub-args (make-list arg-count)))
                   (declare (dynamic-extent sub-args))
                   (mapl #'(lambda (from to) (setf (car to) (car from)))
                         args sub-args)
                   (setf args (nthcdr arg-count args))
                   (apply transformer combination sub-args)))
               (apply transformer combination (shiftf args nil))))))
    (loop (case (first args)
            ((nil) (return))
            (:view (setf target (pop args)) (do-transform #'view-transform))
            (:projection (setf target (pop args)) (do-transform #'projection-transform))
            (t (ecase (or target (first args))
                 (:view (do-transform #'view-transform))
                 (:projection (do-transform #'projection-transform))))))))

;;;
;;; font names

(defun compute-font-parameters (font-spec)
  "given a fontspec (name size :bold :italic :underline :outline :shadow :condense :extend),
   compute the make-opengl-font parameters."
  (let ((name nil)
        (size nil)
        (style 0)
        (style-names nil))
    (dolist (element font-spec)
      (typecase element
        (string (when name (error "Font Spec: ~s contains two names." font-spec))
                (setf name element))
        (integer (when size (error "Font Spec: ~s contains two sizes." font-spec))
                 (setf size element))
        (t
         #+digitool
         (setf style (logior style (or (rest (assoc element ccl::*style-alist*))
                                       (error "Font Spec: ~s contains unknown option." font-spec))))
         (setf style-names (cons element style-names)))))
    (unless (and name size)
      (error "Font Spec: ~s contains lacks name and/or size." font-spec))
    (values name size style (sort style-names #'string-lessp))))

(defGeneric font-spec-name (font-spec)
  (:method ((font-spec list))
           (multiple-value-bind (name size style style-names)
                                (compute-font-parameters font-spec)
             (declare (ignore style))
             (intern (format nil "~:@(~a-~{~a~^+~}-~a~)" name style-names size) :keyword))))



;;;
;;; utilities

(defProjectionOp erase-view ())

(defProjectionOp fill-view (&optional color))

(defun axis (&key (size *context-one*) (location (make-location-world))
                  (label-offset 4))
  (with-location-vectors ((x-axis (+ (location-x location) size)
                                  (location-y location)
                                  (location-z location))
                          (y-axis (location-x location)
                                  (+ (location-y location) size)
                                  (location-z location))
                          (z-axis (location-x location)
                                  (location-y location)
                                  (+ (location-z location) size)))
    (line location x-axis)
    (line location y-axis)
    (line location z-axis)
    (with-port-coordinates* (((x y) x-axis)) *projection-context*
      (when label-offset
        (incf x label-offset)
        (incf y label-offset)
        (text*2 x y "x" t)))
    (with-port-coordinates* (((x y) y-axis)) *projection-context*
      (when label-offset
        (incf x label-offset)
        (incf y label-offset)
        (text*2 x y "y" t)))
    (with-port-coordinates* (((x y) z-axis)) *projection-context*
      (when label-offset
        (incf x label-offset)
        (incf y label-offset)
        (text*2 x y "z" t)))))



:EOF
