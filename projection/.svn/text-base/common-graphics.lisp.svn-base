;;; -*- Mode: LISP; Syntax: Common-lisp; Package: de.setf.object-graphics.implementation; Base: 10; Lowercase: Yes -*-

#|
<DOCUMENTATION>
 <title>allegro common graphics graphics implementation</title>
 <DESCRIPTION>
  <p>
  this file implements the abstract operations for the common-graphics library which accompanies allegro common lisp.
  the implementation is based on the common ndc-transform-context class.</p>
  <p>
  the functions exhibit several forms:
 <dl><dt>.og.::<i>operation</i></dt><dd>include in intial specializer. they are invoked from interface functions to perform operations for the given context.</dd>
     <dt>common-agraphics-</i>operation</i></dt><dd>require an initial cgstream pointer</dd>
     <dt>acg-</i>operation</i></dt><dd>are internal functions and utilities which are specific to common-agraphics but do not depend on the context.</dd>
     <dt>context-</i>operatin</i></dt><dd>require a coregraphics context and implement components things like ndc-specific methods</dd>
     </dl>
  </DESCRIPTION>
 <CHRONOLOGY>
  <DELTA DATE='20030911' AUTHOR='james.anderson@setf.de' >
   </DELTA>
  </CHRONOLOGY>
 </DOCUMENTATION>
|#

(pushnew :og.assert-types *features*)

(in-package :de.setf.object-graphics.implementation)


;;;

(defparameter *common-graphics-view* nil)
(defparameter *common-graphics-pattern*
    (make-instance 'cg:pixmap :name :light-gray-pattern
                   :colors (vector cg:light-gray)
                   :contents '((0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
                               (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))))
(defParameter *common-graphics-raster-operation* cg:po-replace)
(defparameter *common-graphics-foreground-color* nil)

(defParameter *common-graphics-path-drawing-mode-value* cg:po-paint
  "the core graphics path drawing mode value")
(defParameter *common-graphics-color-mode* :source)
(defParameter *common-graphics-color-alpha-factor* 1.0s0)
(defParameter *common-graphics-font* '("courier" 10))

(defParameter *common-graphics-path-level* 0)
(defParameter *common-graphics-arc-orientation* 0)
(defParameter *common-graphics-path-drawing-mode-map*
  `((:erase . ,cg:po-erase)
    (:fill . ,cg:po-fill)            ; treated as fill with temporary background as fill
    (:invert  . ,cg:po-invert)
    (:point  . ,cg:po-paint)        ; treated as stroke
    (:eofill . ,cg:po-fill)
    (:stroke . ,cg:po-paint)
    (:fill-stroke . ,cg:po-paint)
    (:eofill-stroke . ,cg:po-paint)))
(defparameter *common-graphics-paint-operation* cg:po-paint)


   


;;;
;;; class

(defClass common-graphics-context (port-transform-context single-sided-projection-context)
  ((arc-port :initform 'common-graphics-arc-port :allocation :instance)
   (line-port :initform 'common-graphics-line-port :allocation :instance)
   (raster-port :initform 'common-graphics-raster-port :allocation :instance)
   (rectangle-port :initform 'common-graphics-rectangle-port :allocation :instance)
   (text-port :initform 'common-graphics-text-port :allocation :instance))
  (:documentation
   "the context for common-graphics operations"))


;;;
;;; context binding

(defMethod call-with-projection-context
           ((function function) (context common-graphics-context)
                     &key
                     &allow-other-keys)
  (let ((*context-fill-agent* (short-location-vector))
        (*common-graphics-foreground-color* (short-location-vector))
        (*context-clear-agent* (short-location-vector)))
    (call-next-method)))

;;;
;;; macros

(defmacro with-cg-positions (positions &rest body)
  `(let ,(mapcar #'(lambda (position)
                     (destructuring-bind (variable x y) position
                       `(,variable (cg:make-position (round ,x) (round ,y)))))
          positions)
     ,@body))

(defmacro with-common-graphics-foreground-color (color &rest body)
  (let ((fname (gensym)))
    `(flet ((,fname () ,@body))
       (declare (dynamic-extent #',fname))
       (common-graphics-call-with-foreground-color #',fname ,color))))


;;; fonts

(defMethod define-font ((context common-graphics-context) font-spec
                        &optional (name (font-spec-name font-spec)))
  (multiple-value-bind (font-name font-size font-style) (compute-font-parameters font-spec)
    (declare (ignore font-style))
    (setf (context-get context nil name)
      (cg:make-font nil font-name font-size)))
  name)

;;;
;;; 
;;; geometric elements
;;;
;;; these functions draw the basic geometric figures.
;;; NB: they do not take structure objects, rather they require the explicit
;;; points - either as instances or as spread coordinates. all locations are absolute.
;;; the instance

(defun common-graphics-line-port (cgstream location1 location2 aspects)
  "draw a line given the port endpoints"
  (declare (type location-vector location1 location2))
  #+og.assert-types (progn (assert-type cgstream cg:cg-stream)
                           (assert-types (location1 location2) location-vector)
                           (assert-type aspects sequence))
  (with-cg-positions ((p1 (aref location1 0) (aref location1 1))
                      (p2 (aref location2 0) (aref location2 1)))
    (flet ((line-geometry ()
             (cg:draw-line cgstream p1 p2)))
      (declare (dynamic-extent #'line-geometry))
      (call-with-projection-variables #'line-geometry aspects))))


;;;
;;; rectangle

(defun common-graphics-rectangle-port (cgstream location1 location2 properties)
  (declare (type location-vector location1 location2))
  #+og.assert-types (progn (assert-type cgstream cg:cg-stream)
                           (assert-types (location1 location2) location-vector)
                           (assert-type properties sequence))
  ;; allow for erase, point, invert
  ;; should be resourced
  (let ((x1 (%round (aref location1 0))) (y1 (%round (aref location1 1)))
        (x2 (%round (aref location2 0))) (y2 (%round (aref location2 1))))
    (with-cg-positions ((p1 x1 y1) (p2 x1 y2) (p3 x2 y2) (p4 x2 y1))
      (let ((positions (vector p1 p2 p3 p4)))
        (flet ((rectangle-geometry ()
                 (if (eq *context-path-effect* :erase)
                     (cg:erase-polygon cgstream positions)
                   (cg:draw-polygon cgstream positions))))
          (declare (dynamic-extent #'rectangle-geometry))
          (call-with-projection-variables #'rectangle-geometry properties))))))



;;
;; polygon

(defMethod context-poly ((context common-graphics-context) locations &optional aspects)
  "transform a sequence of points to ndc coordinates and render a polygon.
   the ndc position list is stack allocated to accommodate the argument location list
   and populated with resourced position instances."
  #+og.assert-types (progn (assert-types (locations aspects) sequence))
  (let ((get-next-location nil)
        (location-count (length locations))
        (last-index -1)
        (cgstream (context-view context)))
    (declare (type fixnum last-index location-count))
    (when (> location-count 0)
      (flet ((next-list-location ()
               (locally (declare (type list locations))
                 (pop locations)))
             (next-vector-location ()
               (locally (declare (type vector locations))
                 (when (< (incf last-index) location-count)
                   (aref locations last-index)))))
        (declare (dynamic-extent #'next-list-location #'next-vector-location))
        (etypecase locations
          (cons (setf get-next-location #'next-list-location))
          (vector (setf get-next-location #'next-vector-location)))
        (with-location-vectors ((port-location-vector))
          (let* ((location nil)
                 (port-coordinate-count (* location-count 2)))
            (declare (dynamic-extent port-x port-x)
                     (type double-float port-x port-y)
                     (type fixnum port-coordinate-count))
            (let ((port-position-list (make-list port-coordinate-count)))
              (let ((port-position-rest port-position-list)
		    (port-position nil))
                (loop (setf port-position (first port-position-rest))
                  (typecase (setf location (funcall get-next-location))
                    (null (return))
                    (fixnum (setf (cg:position-x port-position) (point-h location)
                                  (cg:position-y port-position) (point-v location)))
                    (location-port (setf (cg:position-x port-position) (location-x location)
                                         (cg:position-y port-position) (location-y location)))
                    (t (location-transform *context-transform* location port-location-vector)
                       (setf (cg:position-x port-position) (aref port-location-vector 0)
                             (cg:position-y port-position) (aref port-location-vector 1))))
                  (setf port-position-rest (rest port-position-rest)))
                (flet ((draw-line-geometry (agent op)
                         (flet ((draw-with-agent ()
                                  (cg:draw-polyline cgstream port-position-list)))
                           (declare (dynamic-extent #'draw-with-agent))
                           (unless (eql op *common-graphics-paint-operation*)
                             (setf (cg:paint-operation cgstream) op
                                   *common-graphics-paint-operation* op))
                           (common-graphics-call-with-foreground-color
                            #'draw-with-agent agent))))
                  (declare (dynamic-extent #'draw-line-geometry))
                  (flet ((poly-properties ()
                           (case *context-path-effect*
                             (:erase (draw-line-geometry *context-clear-agent* cg:po-erase))
                             (:fill (draw-line-geometry *context-fill-agent* cg:po-fill))
                             (:fill-stroke (draw-line-geometry *context-fill-agent* cg:po-fill)
                                           (draw-line-geometry *context-stroke-agent* cg:po-paint))
                             (:invert (draw-line-geometry *context-stroke-agent* cg:po-invert))
                             (:stroke (draw-line-geometry *context-stroke-agent* cg:po-paint))
                             (:point (flet ((draw-with-agent ()
                                              (dolist (position port-position-list)
                                                (cg:draw-line cgstream position position))))
                                       (declare (dynamic-extent #'draw-with-agent))
                                       (common-graphics-call-with-foreground-color
                                        #'draw-with-agent *context-stroke-agent*))))))
                (declare (dynamic-extent #'poly-properties))
                (call-with-projection-variables #'poly-properties aspects)))))))))))



;;;
;;; arc

(defun common-graphics-arc-port (cgstream location radius start-radians end-radians
                                 direction &optional aspects)
  "draw a rectangle given the 2d coordinates"
  #+og.assert-types (progn (assert-type cgstream cg:cg-stream)
                           (assert-type location location-vector)
                           (assert-types (radius start-radians end-radians) number)
                           (assert-type aspects sequence))
  (ecase direction
    (:clockwise )
    (:counterclockwise (rotatef start-radians end-radians)))
  (let* ((width (* radius 2))          ; should have 2-d size
         (height width)
         (arc-geometry-fill-p nil)
         (start-degrees (radians-to-degrees start-radians))
         (end-degrees (radians-to-degrees end-radians))
         (x (%round (aref location 0))) (y (%round (aref location 1))))
    (flet ((draw-arc-geometry ()
             (if arc-geometry-fill-p
                 (cg:with-paint-operation (cgstream cg:po-fill)
                   (cg:draw-ellipse-arc cgstream
                                        (cg:make-position x y)
                                        (/ width 2) (/ height 2)
                                        0
                                        start-degrees
                                        (- end-degrees start-degrees)))
                 (cg:draw-ellipse-arc cgstream
                                      (cg:make-position x y)
                                      (/ width 2) (/ height 2)
                                      0
                                      start-degrees
                                      (- end-degrees start-degrees))))
           (g&p (render pixel fill)
             (unless (eql pixel *common-graphics-foreground-color*)
               (setf (cg:foreground-color cgstream)
                 (setf *common-graphics-foreground-color* pixel)))
             (funcall render)))
      (declare (dynamic-extent #'draw-arc-geometry #'g&p))
      (flet ((arc-properties ()
               (case *context-path-effect*
                 (:erase
                  (g&p #'arc-geometry *context-clear-agent* :winding))
                 ((:eofill :fill)
                  (g&p #'arc-geometry *context-fill-agent* :winding))
                 ((:eofill-stroke :fill-stroke)
                  (g&p #'arc-geometry *context-fill-agent* :winding)
                  (g&p #'arc-geometry *context-stroke-agent* nil))
                 (:invert
                  (cg:with-paint-operation (cgstream cg:po-invert)
                    (g&p #'arc-geometry *context-fill-agent* :winding)))
                 (:stroke (g&p #'arc-geometry *context-stroke-agent* nil))
                 (:point (unless (= *context-stroke-agent* *common-graphics-foreground-color*)
                           (setf (cg:foreground-color cgstream)
                             (setf *common-graphics-foreground-color* *context-stroke-agent*)))
                         (with-cg-positions ((p1 (+ x (* (cos start-radians) radius))
                                                 (+ y (* (sin start-radians) radius)))
                                             (p2 (+ x (* (cos end-radians) radius))
                                                 (+ y (* (sin end-radians) radius))))
                           (cg:draw-line cgstream p1 p1)
                           (cg:draw-line cgstream p2 p2))))))
        (declare (dynamic-extent #'arc-properties))
        (call-with-projection-variables #'arc-properties aspects)))))

   

;;;
;;; text

(defun common-graphics-text-port (cgcontext x y string &optional font aspects)
  #+og.assert-types (progn (assert-type cgcontext cgstream)
                           (assert-types (x y) short-float)
                           (assert-type string string)
                           (assert-type aspects sequence))
  (cond ((eq font t) (setf font *common-graphics-font*)))
  (when font
    (let ((name-size (etypecase font
                       (keyword (get-font *projection-context* font))
                       (cons font))))
      (when name-size
        (destructuring-bind (name size) name-size
          (setf (cg:font cgcontext) (cg:make-font-ex nil name size))))))
  (flet ((render-text ()
           (cg:draw-string-in-box
            cgcontext
            string 0 (length string)
            (cg:make-box x (+ y (cg:line-height cgcontext))
                         (+ x (cg:stream-string-width cgcontext string)) y)
            nil nil)))
    (declare (dynamic-extent #'render-text))
    (call-with-projection-variables #'render-text aspects)))



;;;
;;; raster


(defun common-graphics-raster-port (cgcontext location size raster &optional aspects)
  (declare (type location-vector location size))
  #-og.assert-types (declare (ignore size))
  #+og.assert-types (progn (assert-type cgcontext cg:cg-stream)
                           (assert-type location location-vector)
                           (assert-type size location-vector)
                           (assert-type raster raster)
                           (assert-type aspects sequence))
  (let ((x (%round (aref location 0))) (y (%round (aref location 1)))
        (image (sample-projection raster *projection-context*)))
    (flet ((render-raster ()
             (cg:move-to x y)
             (cg:copy-to-stream cgcontext image cgcontext)))
      (declare (dynamic-extent #'render-raster))
      (call-with-projection-variables #'render-raster aspects))))


(defmethod sample-introjection ((raster raster) (context common-graphics-context))
  )

(defmethod sample-projection ((raster raster) (context common-graphics-context))
  (let ((sample-projection (context-get context raster :common-graphics-image)))
    (unless sample-projection
      (let* ((size (sample-size raster))
             (width (point-h size))
             (height (point-v size))
             (depth (sample-depth raster))
             (sample-data (sample-data raster))
             ;; (bytes-per-pixel (/ depth 8))
             ;; (bytes-per-row (* width bytes-per-pixel))
             ;; (sample 0)
             )
        (let* ((contents
                (loop for i from 0 below height by 1
                    collect
                      (loop for j from 0 below width by 1
                          collect
                            (sample-filter raster (aref sample-data i j) i j))))
               (image
                (make-instance 'cg:pixmap
                  :name raster :bits-per-pixel depth
                  :colors #+(and allegro allegro-version>= (version>= 7 0))
                  (cg:default-pixmap-color-vector)
                  #+(not (and allegro allegro-version>= (version>= 7 0)))
                  (cg:default-palette-vector cg:*system*)
                  :contents contents)))
          (setf sample-projection image)
          (setf (context-get context raster 'cg:pixmap) image))))
    sample-projection))



;;; general utilities
;;;

(defmethod view-size ((view cg::cg-stream))
  (make-point (cg::window-interior-width view)
              (cg::window-interior-height view)))

(defun common-graphics-erase-view (view)
  (cg:erase-box view
                (cg:make-box 0 0
                             (cg::window-interior-width view)
                             (cg::window-interior-height view))))

(defMethod context-erase ((context common-graphics-context))
  (common-graphics-erase-view (context-view context)))

(defun common-graphics-fill-view (view &optional (agent *context-stroke-agent*))
  (with-common-graphics-foreground-color agent
    (cg:fill-box view
                 (cg:make-box 0 0
                              (cg::window-interior-width view)
                              (cg::window-interior-height view)))))

(defMethod context-mark ((context common-graphics-context) &optional (agent *context-stroke-agent*))
  (common-graphics-fill-view (context-view context) agent))





;;;
;;; properties
;;;
;;; colors require parallel state as they cannot be read out (ie there's no CGContextGetFillColor)

(defun common-graphics-call-with-foreground-color (function color)
  ;; common graphics has foreground and background state only
  ;; fill and mark agents are multiplexed over this
  (if (eq color *common-graphics-foreground-color*)
    (funcall function)
    (with-coerced-variables ((short-location-vector color))
      (let ((old-color *common-graphics-foreground-color*)
            (*common-graphics-foreground-color* color))
        (unwind-protect
            (progn (setf (cg:foreground-color *context-view*)
                     (cg:make-rgb :red (aref *context-fill-agent* 0)
                                  :green (aref *context-fill-agent* 1)
                                  :blue  (aref *context-fill-agent* 2)))
                   (funcall function))
          (cg:make-rgb :red (aref old-color 0)
                       :green (aref old-color 1)
                       :blue  (aref old-color 2)))))))



(defun common-graphics-set-fill-agent (cgstream r g b &optional (a 1.0s0))
  (declare (optimize (speed 3) (safety 0))
           (ignore cgstream))
  (with-short-float-intensity-variables (r g b a)
    (with-coerced-variables ((short-location-vector *context-fill-agent*))
      (setf (aref *context-fill-agent* 0) r
            (aref *context-fill-agent* 1) g
            (aref *context-fill-agent* 2) b
            (aref *context-fill-agent* 3) a)
      *context-fill-agent*)))

(defMethod context-set-fill-agent*3 ((context common-graphics-context) r g b)
  (common-graphics-set-fill-agent (context-view context) r g b 1.0s0))

(defMethod context-set-fill-color*4 ((context common-graphics-context) r g b &optional a)
  ; optional to allow call from fill-color w/o length check
  (common-graphics-set-fill-agent (context-view context) r g b (if a a 1.0s0)))

(defMethod context-set-fill-agent ((context common-graphics-context) color &optional g b a)
  (etypecase color
    (number
     (common-graphics-set-fill-agent (context-view context) color g b (if a a 1.0s0)))
    (cons
     (apply #'common-graphics-set-fill-agent (context-view context)
            (if (symbolp (first color)) (rest color) color)))
    ((or vector location-3)
     (with-coerced-variables ((short-location-vector *context-fill-agent*))
       (location-vector-copy color *context-fill-agent*)
       *context-fill-agent*))))

(defMethod context-save-fill-agent ((context common-graphics-context))
  (flet ((reset-fill-and-release-vector (context color)
           (context-set-fill-agent context color)
           (return-short-location-vector color)))
    (push-projection-variables #'reset-fill-and-release-vector context
                             (location-vector-copy *context-fill-agent* (get-short-location-vector)))))



(defun common-graphics-set-stroke-agent (cgstream r g b &optional (a 1.0s0))
  (declare (optimize (speed 3) (safety 0))
           (ignore cgstream))
  (with-short-float-intensity-variables (r g b a)
    (with-coerced-variables ((short-location-vector *context-stroke-agent*))
      (setf (aref *context-stroke-agent* 0) r
            (aref *context-stroke-agent* 1) g
            (aref *context-stroke-agent* 2) b
            (aref *context-stroke-agent* 3) a)
       *context-stroke-agent*)))

(defMethod context-set-stroke-agent*3 ((context common-graphics-context) r g b)
  (common-graphics-set-stroke-agent (context-view context) r g b 1.0s0))

(defMethod context-set-stroke-agent*4 ((context common-graphics-context) r g b &optional a)
  (common-graphics-set-stroke-agent (context-view context) r g b (if a a 1.0s0)))

(defMethod context-set-stroke-agent ((context common-graphics-context) color &optional g b a)
  (etypecase color
    (number
     (common-graphics-set-stroke-agent (context-view context) color g b (if a a 1.0s0)))
    (cons
     (apply #'common-graphics-set-stroke-agent (context-view context)
            (if (symbolp (first color)) (rest color) color)))
    ((or vector location-3)
     (with-coerced-variables ((short-location-vector *context-stroke-agent*))
       (location-vector-copy color *context-stroke-agent*)
       *context-stroke-agent*))))

(defMethod context-save-stroke-agent ((context common-graphics-context))
  (flet ((reset-stroke-and-release-vector (context color)
           (context-set-stroke-agent context color)
           (return-short-location-vector color)))
    (push-projection-variables #'reset-stroke-and-release-vector context
                             (location-vector-copy *context-stroke-agent* (get-short-location-vector)))))




(defun common-graphics-set-clear-agent (cgstream r g b &optional (a 1.0s0))
  (declare (optimize (speed 3) (safety 0)))
  (with-short-float-intensity-variables (r g b a)
    (with-coerced-variables ((short-location-vector *context-clear-agent*))
      (setf (cg:background-color cgstream)
        (cg:make-rgb :red r :green g :blue b))
      (setf (aref *context-clear-agent* 0) r
            (aref *context-clear-agent* 1) g
            (aref *context-clear-agent* 2) b
            (aref *context-clear-agent* 3) a)
      *context-clear-agent*)))
  
(defMethod context-set-clear-agent*3 ((context common-graphics-context) r g b)
  (common-graphics-set-clear-agent (context-view context) r g b 1.0s0))

(defMethod context-set-clear-agent*4 ((context common-graphics-context) r g b &optional a)
  (common-graphics-set-clear-agent (context-view context) r g b (if a a 1.0s0)))

(defMethod context-set-clear-agent ((context common-graphics-context) color &optional g b a)
  (etypecase color
    (number
     (common-graphics-set-clear-agent (context-view context) color g b (if a a 1.0s0)))
    (cons
     (apply #'common-graphics-set-clear-agent (context-view context)
            (if (symbolp (first color)) (rest color) color)))
    ((or vector location-3)
     (with-coerced-variables ((short-location-vector *context-clear-agent*))
       (location-vector-copy color *context-clear-agent*)
       *context-clear-agent*))))

(defMethod context-save-clear-agent ((context common-graphics-context))
  (flet ((reset-background-and-release-vector (context color)
           (context-set-clear-agent context color)
           (return-short-location-vector color)))
    (push-projection-variables #'reset-background-and-release-vector context
                             (location-vector-copy *context-clear-agent* (get-short-location-vector)))))




;;;
;;; path effect

(defMethod context-set-path-effect ((context common-graphics-context) effect)
  (setf *common-graphics-path-drawing-mode-value*
        (or (rest (assoc effect *common-graphics-path-drawing-mode-map*))
            (error "invalid path mode: ~s." effect)))
  (setf *context-path-effect* effect))

(defMethod context-save-path-effect ((context common-graphics-context))
  (push-projection-variables #'context-set-path-effect context *context-path-effect*))


;;;
;;; path constituents

(defMethod context-set-path-constituents ((context common-graphics-context) constituents)
  (declare (ignore back))
  (setf *context-path-constituents* constituents))

(defMethod context-save-path-constituents ((context common-graphics-context))
  (push-projection-variables #'context-set-path-constituents context *context-path-constituents*))




;;;
;;; color mode

(defMethod context-set-color-mode ((context common-graphics-context) mode &rest args)
  "core graphics supports a alpha combination factor for images?"
  (declare (ignore mode args))
  ;; no support for color modes
  )

(defMethod context-save-color-mode ((context common-graphics-context))
  ;; no support for color modes
  )
  


;;;
;;; transforms
;;;
;;; according to http://www.franz.com/support/documentation/7.0.beta/doc/cg/cg-coordinates.htm
;;; the options for scaling provided by the mixin class scaling-stream. in fact, however,
;;; it supports transformations epxressed in units-per-inch or units-per-mm and - at least in
;;; the supported interface. which means that the only rational approach is to address the
;;; context in port coordinates only and do all transforms as part of this rendering layer.
;;;
;;; thus there is no transform code here. see port-context.lisp





#|


(defParameter *w* (make-instance 'window :color-p t :view-size (make-point 256 256)))
(defparameter *cgc* (make-instance 'common-graphics-context :view *w*))

(defun test-cg (function)
  (call-with-projection-context function *cgc*))

(defun graphics-sampler ()
  (line*3 0.0d0 0.0d0 0.0d0 100.0d0 100.0d0 100.0d0))

(trace line*3 common-graphics-line*2ndc common-graphics-line*3)

(test-cg #'graphics-sampler)


|#
:eof
