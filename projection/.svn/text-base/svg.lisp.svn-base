;;; -*- Mode: LISP; Syntax: Common-lisp; Package: de.setf.object-graphics.implementation; Base: 10; Lowercase: Yes -*-

#|
<DOCUMENTATION>
 <title>open gl graphics implementation</title>
 <DESCRIPTION>
  <p>
  this file implements the concrete projection operations for an svg serializer.
  the output is generated in an ndc space with a default port transform to map (0,0) x (1,1) to the respective
  context's size.
  the implementation depends cl-xml for serialization.</p>
  </DESCRIPTION>
 <CHRONOLOGY>
  <DELTA DATE='20061017' AUTHOR='james.anderson@setf.de' >
   </DELTA>
  </CHRONOLOGY>
 </DOCUMENTATION>
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package :de.setf.object-graphics.implementation)


(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (xqdm:find-namespace "svg" :if-does-not-exist nil)
    (xqdm:defnamespace "http://www.w3.org/2000/svg"
      (:nicknames "svg")
      (:export "svg" "circle" "line" "rect" "polygon" "polyline" "text"))))


;;;
;;; parameters

(defparameter *svg-version* "1.1")

(defparameter *svg-fill-color* nil)
(defparameter *svg-stroke-color* nil)
(defparameter *svg-clear-color* "0.0,0.0,0.0,0.0")
(defparameter *svg-style* nil)
(defparameter *svg-path-constituents* :lines)
(defparameter *svg-path-effect* :paint)
(defparameter *svg-color-mode* :opaque)
(defparameter *svg-color-args* nil)
(defparameter *svg-font* "font-weight: normal; font-size: 10pt; font-family: courier;"
  "binds the current font property as a shorthand, in the form,
   font-family: <'font-family'>; font-size: <'font-size'>; font-weight: <'font-weight'>; font-style: <'font-style'>[; font-stretch: <'font-stretch'> ]
  (see http://www.w3.org/TR/REC-CSS2/fonts.html#q1).")
(defparameter *svg-transform-attribute* nil
  "optionally binds an accumulated transform attribute. the initial value, yields no attribute.
   successive view transforms are collected in a fill buffer and added to any element.")

(defparameter *svg-one* 1.0s0)
(defparameter *svg-zero* 0.0s0)


;;;
;;; the context class

(defclass svg-presenter () ()
  (:documentation
   "the abstract class which entails the presence of the svg presentation methods"))

(defclass svg-context (svg-presenter dimensioned-context ndc-transform-context single-sided-projection-context)
  ((arc-ndc :initform 'svg-arc-ndc :allocation :class)
   (line-ndc :initform 'svg-line-ndc :allocation :class)
   (raster-ndc :initform 'svg-raster-ndc :allocation :class)
   (rectangle-ndc :initform 'svg-rectangle-ndc :allocation :class)
   (text-ndc :initform 'svg-text-ndc :allocation :class)
   (stream
    :initform nil :initarg :stream
    :reader context-stream
    :documentation "bound to an output stream with-svg-context form.")
   (xml-version
    :initform xmlp::*xml-version* :initarg :xml-version
    :reader context-xml-version)
   (document-type
    :initform *svg-document-type-properties* :initarg :document-type
    :reader context-document-type)
   (svg-version
    :initform *svg-version* :initarg :svg-version
    :reader context-svg-version)
   (uri-scheme
    :initform :svg :allocation :class))
  (:documentation
   "a context which implements graphics operations as svg serialization.
    it binds the respective ndc methods and a stream for serialization."))


;;; 20061016 - eliminated synonym contexts


;;;
;;; context management

(defmacro with-svg-writer (control-arguments &rest body)
  `(let ((*read-default-float-format* 'single-float))
     (xmlp:with-xml-writer ,control-arguments ,@body)))

(defmacro with-svg-to-string ((&rest initargs &key (xml-version nil) (svg-version nil) (document-type nil))
                              &rest body)
  (remf initargs :xml-version)
  (remf initargs :svg-version)
  (remf initargs :document-type)
  `(with-output-to-string (xml-string-stream)
     (with-projection-context ((make-instance 'svg-context :stream xml-string-stream
                                              :xml-version ,xml-version
                                              :svg-version ,svg-version
                                              :document-type ,document-type
                                              ,@initargs))
       ,@body)))

(defparameter *svg-external-identifier* "-//W3C//DTD SVG 1.1//EN")
(defparameter *svg-system-identifier* "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd")
(defparameter *svg-document-type-name* "svg")

(defparameter *svg-document-type-properties*
  `(:name ,*svg-document-type-name* :external-id ,*svg-external-identifier* :system-id ,*svg-external-identifier*))

(defun call-with-svg-context (function context &key
                                       (stream (context-stream context))
                                       (element '{svg}svg)
                                       (xml-version (context-xml-version context))
                                       (svg-version (context-svg-version context))
                                       (document-type (context-document-type context))
                                       &allow-other-keys)
  "assert a svg serialization context and execute the body. the stream argument specifies the serialization
   destination."
  (let ((*context-path-constituents* *svg-path-constituents*))
    (xmlp:with-xml-writer (stream)
      (etypecase element
        (function 
         (funcall function))
        ((or symbol xqdm:uname)
         (let ((size (context-size context)))
           (when xml-version
             (xmlp:encode-format "<?xml version='~a' standalone='~a' ?>"
                            xml-version (if document-type "no" "yes"))
             (xmlp:encode-newline))
           (when document-type
             (destructuring-bind (&key (name "svg") (external-id *svg-external-identifier*)
                                       (system-id *svg-system-identifier*))
                                 document-type
               (xmlp:encode-format "<!DOCTYPE ~a PUBLIC '~a' '~a'> "
                              name external-id system-id))
             (xmlp:encode-newline))
           (xmlp:xml ({svg}svg ({}width (point-h size)) ({}height (point-v size))
                               ({}version svg-version))
             (xmlp:xml ({svg}g ({}transform #'(lambda ()
                                                (xmlp:encode-format "translate(~d,~d), scale(~d,~d)"
                                                               (floor (/ (point-h size) 2.0))
                                                               (floor (/ (point-v size) 2.0))
                                                               (floor (/ (point-h size) 2.0))
                                                               (floor (/ (point-v size) -2.0)))))
                               ({}stroke-width #'(lambda ()
                                                   (xmlp:encode-format "~f" (/ 1.0 (max (point-h size) (point-v size)))))))
                     (funcall function)))))))))

(defMethod call-with-projection-context
           ((function function) (context svg-context) &rest args)
  (declare (dynamic-extent args))
  (apply #'call-with-svg-context #'call-next-method context args))

(defmethod context-ndc-context ((context svg-context))
  context)


(defmethod define-font ((context svg-context) font-spec name)
  (setf (get-font context name)
        (svg-font-designator font-spec))
  name)

(defgeneric svg-font-designator (font-spec)
  (:method ((designator string))
           "a string is used as-is."
           designator)
  (:method ((font-spec cons))
           (multiple-value-bind (family point-size style-names)
                                (compute-font-parameters font-spec)
             (declare (ignore style))
             (let ((weight (cond ((find :bold style-names) "bold")
                                 ((find :light style-names) "lighter")
                                 (t "normal")))
                   (slant (cond ((find :italic style-names) "italic")
                                ((find :oblique style-names) "oblique")
                                (t nil)))
                   (width (cond ((or (find :narrow style-names) (find :condensed style-names)) "condensed")
                                ((or (find :wide style-names) (find :expanded style-names)) "expanded")
                                (t nil))))
               (format nil "~(font-family: ~:[~a~;'~a'~]; font-size: ~apt; font-weight: ~a;~@[ font-style: ~a;~]~@[ font-stretch: ~a;~]~)"
                       (find #\space family) family
                       point-size weight slant width)))))
  

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; geometric elements
;;;
;;; each encodes a svg element given the ndc locations and optional attributes

;;;
;;; line

(defun svg-line-ndc (context l1 l2 &optional attributes)
  "encode a svg line given the ndc endpoint locations and the line attributes."
  (declare (ignore context))
  #+og.assert-types (progn (assert-types (l1 l2) location-vector)
                           (assert-type attributes sequence))
  (with-short-location-coordinates ((l1 x1 y1) (l2 x2 y2))
    (labels ((line-geometry ()
               (if (eq *svg-path-effect* :erase)
                 (let ((*svg-stroke-color* *svg-clear-color*)
                       (*svg-path-effect* :paint))
                   (line-geometry))
	         (xmlp:xml ({svg}line ({}x1  #'(lambda () (xmlp:encode-format "~f" x1)))
                                      ({}y1  #'(lambda () (xmlp:encode-format "~f" y1)))
			              ({}x2  #'(lambda () (xmlp:encode-format "~f" x2)))
                                      ({}y2  #'(lambda () (xmlp:encode-format "~f" y2(abs (- y2 y1)))))
			              ({}stroke *svg-stroke-color*)
			              ({}style *svg-style*))))))
      (declare (dynamic-extent #'line-geometry))
      (call-with-projection-variables #'line-geometry attributes))))


;;;
;;; rectangle

(defun svg-rectangle-ndc (context l1 l2 l3 l4 &optional attributes)
  "encode a svg rectangle given the ndc endpoint locations and the line attributes."
  (declare (ignore context))
  (declare (type location-vector l1 l2 l3 l4))
  ;; this is not right : it should be a closed polyline trhough the four vertices.
  #+og.assert-types (progn (assert-types (l1 l2 l3 l4) location-vector)
                           (assert-type attributes sequence))
  (with-short-location-coordinates ((l1 x1 y1) (l2 x2 y2) (l3 x3 y3) (l4 x4 y4))
    (labels ((rectangle-geometry ()
             (if (eq *svg-path-effect* :erase)
               (let ((*svg-stroke-color* *svg-clear-color*)
                     (*svg-fill-color* *svg-clear-color*)
                     (*svg-path-effect* :paint))
                 (rectangle-geometry))
               (xmlp:xml ({svg}rect ({}x  #'(lambda () (xmlp:encode-format "~f" (min x1 x3))))
                                    ({}y  #'(lambda () (xmlp:encode-format "~f" (min y1 y3))))
			            ({}width  #'(lambda () (xmlp:encode-format "~f" (abs (- x3 x1)))))
                                    ({}height  #'(lambda () (xmlp:encode-format "~f" (abs (- y3 y1)))))
			            ({}style *svg-style*)
			            ({}stroke (ecase *context-path-constituents*
                                                ((:points :lines) *svg-stroke-color*)
                                                (:surfaces nil)))
			            ({}fill (ecase *context-path-constituents*
                                              ((:points :lines) nil)
                                              (:surfaces *svg-fill-color*))))))))
      (declare (dynamic-extent #'rectangle-geometry))
      (call-with-projection-variables #'rectangle-geometry attributes))))


;;;
;;; polygon

(defmethod context-poly ((context svg-context) (locations sequence) &optional attributes)
  "encode a polygon or polyline given a sequence of ndc locations.
   observe the path constituents and close a surface polygon"
  #+og.assert-types (progn (assert-types (locations attributes) sequence))
  (let ((get-next-location nil)
        (location-count (length locations))
        (last-index -1)
        (first-x nil)
        (first-y nil)
        (closed-p nil))
    (declare (type fixnum last-index location-count))
    (when (> location-count 0)
      (flet ((next-list-location ()
               (locally (declare (type list locations))
                 (pop locations)))
             (next-vector-location ()
               (locally (declare (type vector locations))
                 (when (< (incf last-index) location-count)
                   (aref locations last-index)))))
        (declare (dynamic-extent #'next-list-location #'next-vector-location))
        (etypecase locations
          (cons (setf get-next-location #'next-list-location))
          (vector (setf get-next-location #'next-vector-location)))
        (labels ((path-geometry ()
                   (if (eq *svg-path-effect* :erase)
                     (let ((*svg-fill-color* *svg-clear-color*)
                           (*svg-stroke-color* *svg-clear-color*)
                           (*svg-path-effect* :paint))
                       (path-geometry))
                     (with-location-vectors ((ndc-location))
                       (let ((location nil))
                         (xmlp:xml ((ecase *context-path-constituents*
                                      ((:lines :points) '{svg}polyline)
                                      (:surfaces '{svg}polygon))
                                    ({}points #'(lambda ()
                                                  ;; iterate over locations emitting them as an attribute value
                                                  (loop (typecase (setf location (funcall get-next-location))
                                                          (null (return))
                                                          (fixnum (setf (aref ndc-location 0) (* 1.0d0 (point-h location))
                                                                        (aref ndc-location 1) (* 1.0d0 (point-v location)))
                                                                  (setf location ndc-location))
                                                          (location-ndc )
                                                          (t (location-transform *context-projection-transform* location ndc-location)
                                                             (setf location ndc-location)))
                                                        (with-short-location-coordinates ((location ndc-x ndc-y))
                                                          (if first-x
                                                            (setf closed-p (and (= first-x ndc-x) (= first-y ndc-y)))
                                                            (setf first-x (* ndc-x 1.0f0)
                                                                  first-y (* ndc-y 1.0f0)))
                                                          (xmlp:encode-format "~f,~f " ndc-x ndc-y)))
                                                  (when (and (eq *context-path-constituents* :surfaces) (not closed-p))
                                                    (xmlp:encode-format "~f,~f " first-x first-y))))
                                    ({}style *svg-style*)
                                    ({}stroke (ecase *context-path-constituents*
                                                ((:points :lines) *svg-stroke-color*)
                                                (:surfaces nil)))
                                    ({}fill (ecase *context-path-constituents*
                                              ((:points :lines) nil)
                                              (:surfaces *svg-fill-color*))))))))))
          (declare (dynamic-extent #'path-geometry))
          (call-with-projection-variables #'path-geometry attributes))))))

(defmethod context-poly ((context svg-context) (locations function) &optional attributes)
  "encode a polygon or polyline given a function which generates ndc locations.
   observe the path constituents and close a surface polygon"
  #+og.assert-types (progn (assert-types (locations attributes) sequence))
  (svg-poly locations attributes))

(defun svg-poly (locations attributes)
  "auxiliary operator for polyline/gon encoding to use for arcs as well as general curves."
  (labels ((path-geometry ()
             (if (eq *svg-path-effect* :erase)
               (let ((*svg-fill-color* *svg-clear-color*)
                     (*svg-stroke-color* *svg-clear-color*)
                     (*svg-path-effect* :paint))
                 (path-geometry))
               (with-location-vectors ((ndc-location))
                 (let ((first-x nil)
                       (first-y nil)
                       (closed-p nil))
                   (xmlp:xml ((ecase *context-path-constituents* ((:lines :points) '{svg}polyline) (:surfaces '{svg}polygon))
                              ({}points #'(lambda ()
                                            (flet ((vertex-generator (location)
                                                     (typecase location
                                                       (fixnum (setf (aref ndc-location 0) (* 1.0d0 (point-h location))
                                                                     (aref ndc-location 1) (* 1.0d0 (point-v location)))
                                                               (setf location ndc-location))
                                                       (location-ndc )
                                                       (t (location-transform *context-projection-transform* location ndc-location)
                                                          (setf location ndc-location)))
                                                     (with-short-location-coordinates ((location ndc-x ndc-y))
                                                       (if first-x
                                                         (setf closed-p (and (= first-x ndc-x) (= first-y ndc-y)))
                                                         (setf first-x (* ndc-x 1.0f0)
                                                               first-y (* ndc-y 1.0f0)))
                                                       (xmlp:encode-format "~f,~f "  ndc-x ndc-y))))
                                              (declare (dynamic-extent #'vertex-generator))
                                              (funcall locations #'vertex-generator))
                                            (when (and (eq *context-path-constituents* :surfaces) (not closed-p))
                                              (xmlp:encode-format "~f,~f " first-x first-y))))
                              ({}style *svg-style*)
                              ({}stroke (ecase *context-path-constituents*
                                          ((:points :lines) *svg-stroke-color*)
                                          (:surfaces nil)))
                              ({}fill (ecase *context-path-constituents*
                                        ((:points :lines) nil)
                                        (:surfaces *svg-fill-color*))))))))))
    (declare (dynamic-extent #'path-geometry))
    (call-with-projection-variables #'path-geometry attributes)))


;;;
;;; arc
  
(defun svg-arc-ndc (context location radius start end direction &optional attributes)
  "encode an arc given the ndc coordinates, radius, and start/end angles."
  (declare (ignore context))
  (declare (type location-vector location))
  #+og.assert-types (progn (assert-type location location-vector)
                           (assert-types (radius start end) number)
                           (assert-type attributes sequence))
  (if (< (abs (- (abs (- start end)) +2pi+)) short-float-epsilon)
    (labels ((render-circle ()
               (if (eq *svg-path-effect* :erase)
                 (let ((*svg-fill-color* *svg-clear-color*)
                       (*svg-stroke-color* *svg-clear-color*)
                       (*svg-path-effect* :paint))
                   (render-circle))
                 (with-short-location-coordinates ((location cx cy)) 
                   (xmlp:xml ({svg}circle ({}cx  #'(lambda () (xmlp:encode-format "~f" cx)))
                                          ({}cy  #'(lambda () (xmlp:encode-format "~f" cy)))
			                  ({}r  #'(lambda () (xmlp:encode-format "~f" radius)))
			                  ({}style *svg-style*)
			                  ({}stroke (ecase *context-path-constituents*
                                                      ((:points :lines) *svg-stroke-color*)
                                                      (:surfaces nil)))
			                  ({}fill (ecase *context-path-constituents*
                                                    ((:points :lines) nil)
                                                    (:surfaces *svg-fill-color*)))))))))
      (declare (dynamic-extent #'render-circle))
      (call-with-projection-variables  #'render-circle attributes))
    (with-location-coordinates (((wx wy wz) location))
      (with-coerced-variables ((double-float start end))
        (let ((scalar-radius 0.0d0)
              (vertex (location-ndc )))
          (declare (type double-float scalar-radius))
          (etypecase radius
            ;; a scalar radius is used literally
            (number (setf scalar-radius radius))
            ;; a location vector has the magnitude calculated "in-place"
            (location-vector
             (locally (declare (type location-vector radius))
               (location-magnitude radius)
               (setf scalar-radius (aref radius 3))))
            ;; any other location returns the magnitude value
            ((or location-2 cons)
             (setf scalar-radius (location-magnitude radius))))
          (ecase direction
            (:clockwise)
            (:counterclockwise (rotatef start end)))
          (let* ((count (compute-arc-vertex-count scalar-radius start end))
                 (d-theta (/ (- end start) count))
                 (first-p t)
                 (start-x 0.0d0)
                 (start-y 0.0d0))
            (flet ((generate-arc-vertices (writer)
                     (let ((t-cos 0.0d0)
                           (t-sin 0.0d0)
                           (theta 0.0d0))
                       (declare (type double-float t-cos t-sin theta)
                                (dynamic-extent t-cos t-sin theta))
                       (dotimes (i (+ count 1))
                         (setf theta (+ start (* i d-theta)))
                         (sin! theta t-sin)
                         (cos! theta t-cos)
                         (setf (location-x vertex) (+ wx (* scalar-radius t-cos))
                               (location-y vertex) (+ wy (* scalar-radius t-sin)))
                         (when first-p
                           (setf first-p nil
                                 start-x (location-x vertex)
                                 start-y (location-y vertex)))
                         (funcall writer vertex))
                       (when (eq *context-path-constituents* :surfaces)
                         (setf (location-x vertex) wx
                               (location-y vertex) wy)
                         (funcall writer vertex)
                         (setf (location-x vertex) start-x
                               (location-y vertex) start-y)
                         (funcall writer vertex)))))
              (declare (dynamic-extent #'generate-arc-vertices))
              (svg-poly #'generate-arc-vertices attributes))))))))


;;;
;;; text


(defun svg-text-ndc (context location string font &optional attributes)
  "encode a text element given an ndc location, a string and a font.
   if T is specified as the font, use the current font.
   observe the path constituents and close a surface polygon"
  (declare (type svg-context)
           (type location-vector location)
           (type string string))
  #+og.assert-types (progn (assert-type context svg-context)
                           (assert-type location location-vector)
                           (assert-type string string)
                           (assert-type attributes sequence))
  (with-short-location-coordinates ((location x y))
    (when font
      (let ((font-style (etypecase font
                          ((member t) *svg-font*)
                          (string font)
                          (keyword (get-font context font))
                          (cons (svg-font-designator font)))))
        (labels ((render-text () 
                   (if (eq *svg-path-effect* :erase)
                     (let ((*svg-stroke-color* *svg-clear-color*)
                           (*svg-path-effect* :paint))
                       (render-text))
                     (xmlp:xml ({svg}text ({}x x) ({}y y)
                                          ({}style font-style)
                                          ({}color *svg-stroke-color*))
                               (xmlp:encode-string string)))))
          (declare (dynamic-extent #'render-text))
          (call-with-projection-variables #'render-text attributes))))))


;;;
;;; raster


(defun svg-raster-ndc (context location1 location2 raster &optional s)
  (declare (ignore context))
  #+og.assert-types (progn (assert-types (location1 location2) location-vector)
                           (assert-type raster raster)
                           (assert-type attributes sequence))
  ;; this would be implemented by translating to base-64 encoded gif on-the-fly, 
  ;; and including it inline in a data: url.
  (warn "NYI: svg raster."))




;;; general utilities
;;;


(defMethod context-clear-view ((context svg-context))
  (xmlp:xml ({svg}rect ({}x "0.0")
                       ({}y "0.0")
                       ({}width "1.0")
                       ({}height "1.0")
                       ({}fill *svg-clear-color*))))

(defMethod context-fill-view ((context svg-context) &optional (fill nil))
  (xmlp:xml ({svg}rect ({}x "0.0")
                       ({}y "0.0")
                       ({}width "1.0")
                       ({}height "1.0")
                       ({}fill (if fill
                                 (svg-color fill)
                                 *svg-fill-color*)))))


;;;
;;; attributes
;;;
;;; one global parameter exists for each aspect each constituent establishes an
;;; initially null dynamic binding for each aspect which it can emit. the respective
;;; concrete projection function asserts the appropriate values for the binding
;;; depending on whether it is to appear as an attribute - a cons cell, as content -
;;; as an atomic value or a node, or needs to be handled in a mode complex fashion - 
;;; as a function
;;; 

(defmacro with-svg-color ((variable designator) &rest body)
  `(let ((,variable (svg-get-color ,designator)))
     ,@body))

(defmacro with-svg-fill-color ((designator) &rest body)
  `(with-svg-color (*svg-fill-color* ,designator) ,@body))

(defgeneric svg-color (designator)
  (:method ((designator vector))
           (with-location-coordinates (((r g b a) designator))
             (format nil "~f,~f,~f,~f" r g b a)))
  (:method ((color string)) color)
  (:method ((designator location-rgba))
           (with-location-coordinates (((r g b a) designator))
             (format nil "~f,~f,~f,~f" r g b a))))
           



(defun svg-fill-agent*4 (r g b &optional (a 1.0d0))
  (declare (optimize (speed 3) (safety 0)))
  (setq *svg-fill-color* (format nil "~f,~f,~f,~f" r g b a)))

(defMethod context-fill-agent*3 ((context svg-context) r g b)
  (svg-fill-agent*4 r g b 1.0d0))

(defMethod context-fill-agent*4 ((context svg-context) r g b &optional (a 1.0d0))
  ; optional to allow call from fill-agent w/o length check
  (svg-fill-agent*4 r g b a))

(defMethod context-set-fill-agent ((context svg-context) color &optional g b (a 1.0d0))
  (etypecase color
    (number
     (svg-fill-agent*4 color g b (if a a 1.0d0)))
    (cons
     (apply #'context-fill-agent*4 context (if (symbolp (first color)) (rest color) color)))
    ((or vector location-3)
     (with-coerced-variables ((short-location-vector color))
       (with-location-coordinates (((r g b a) color))
         (svg-fill-agent*4 r g b a))))))

(defMethod context-save-fill-agent ((context svg-context))
  (flet ((reset-fill (color)
           (setq *svg-fill-color* color)))
    (push-projection-variable #'reset-fill *svg-fill-color*)))



(defun svg-stroke-agent*4 (r g b &optional (a *svg-one*))
  (setq *svg-stroke-color* (format nil "~f,~f,~f,~f" r g b a)))

(defMethod context-stroke-agent*3 ((context svg-context) r g b)
  (svg-stroke-agent*4 r g b 1.0d0))

(defMethod context-stroke-agent*4 ((context svg-context) r g b &optional (a *svg-one*))
  (svg-stroke-agent*4 r g b a))

(defMethod context-set-stroke-agent ((context svg-context) color &optional g b (a *svg-one*))
  (etypecase color
    (number
     (svg-stroke-agent*4 color g b (if a a *svg-one*)))
    (cons
     (apply #'svg-stroke-agent*4 (if (symbolp (first color)) (rest color) color)))
    ((or vector location-3)
     (with-coerced-variables ((short-location-vector color))
       (with-location-coordinates (((r g b a) color))
         (svg-stroke-agent*4 r g b a))))))

(defMethod context-save-stroke-agent ((context svg-context))
  (flet ((reset-stroke (color)
           (setq *svg-stroke-color* color)))
    (push-projection-variable #'reset-stroke *svg-stroke-color*)))



(defun svg-clear-agent*4 (r g b &optional (a 1.0s0))
  (setq *svg-clear-color* (format nil "~f,~f,~f,~f" r g b a)))
  
(defMethod context-clear-agent*3 ((context svg-context) r g b)
  (svg-clear-agent*4 r g b 1.0d0))

(defMethod context-clear-agent*4 ((context svg-context) r g b &optional (a 1.0s0))
  (svg-clear-agent*4 r g b a))

(defMethod context-set-clear-agent ((context svg-context) color &optional g b (a 1.0d0))
  (etypecase color
    (number
     (svg-clear-agent*4 color g b (if a a 1.0d0)))
    (cons
     (apply #'svg-clear-agent*4 (if (symbolp (first color)) (rest color) color)))
    ((or vector location-3)
     (with-coerced-variables ((short-location-vector color))
       (with-location-coordinates (((r g b a) color))
         (svg-clear-agent*4 r g b a))))))

(defMethod context-save-clear-agent ((context svg-context))
  (flet ((reset-clear (color)
           (setq *svg-clear-color* color)))
    (push-projection-variable #'reset-clear *svg-clear-color*)))




;;;
;;; color mode

(defMethod context-color-mode ((context svg-context) mode &rest args)
  (declare (dynamic-extent args))
  (setq *svg-color-mode* mode
        *svg-color-args* args))

(defMethod context-save-color-mode ((context svg-context))
  (flet ((set-color-mode (mode args)
           (setq *svg-color-mode* mode
                 *svg-color-args* args)))
    (push-projection-variable #'set-color-mode
                              *svg-color-mode* *svg-color-args*)))
  


;;;
;;; transforms

;;; it is not possible to assert a transform.
;;; the only mechanism is to chage the transform by scaleing, translating, rotating
;;; or by catenating a full matrix.

(defun svg-collect-transform (buffer op args)
  (flet ((format-transform (control &rest args)
           (declare (dynamic-extent args))
           (when (plusp (length buffer))
             (vector-push-extend #\, buffer)
             (vector-push-extend #\space buffer))
           (apply #'format buffer control args)))
    (ecase op
      (:scale (destructuring-bind (x &optional y z) args
                (declare (ignorable z))
                (spread-optional-coordinates_ x y z)
                (format-transform "scale(~f,~f)" x y)))
      (:translate (destructuring-bind (x &optional y z) args
                    (declare (ignorable z))
                    (spread-optional-coordinates_ x y z)
                    (format-transform "translate(~f,~f)" x y)))
      (:rotate (destructuring-bind (x &optional y z) args
                 (spread-optional-coordinates_ x y z)
                 (format-transform "rotate(~f)" z)))
      (:catenate (destructuring-bind (delta &rest entries) args
                 (declare (dynamic-extent entries))
                 (with-matrices (new-m)
                   (etypecase delta
                     (number (apply #'matrix-fill new-m delta entries))
                     (simple-array ))
                   (format-transform "matrix(~f,~f,~f,~f,~f,~f)"
                                     (aref new-m 0 0) (aref new-m 0 1)
                                                     (aref new-m 1 0) (aref new-m 1 1)
                                                     (aref new-m 2 0) (aref new-m 2 1)))))
      ((:clear :initialize :set)
       (warn "operation not supported: ~s." op)))))

(defMethod context-set-view-transform ((context svg-context) op &rest args)
  (declare (dynamic-extent args))
  (unless *svg-transform-attribute*
    (setq *svg-transform-attribute* (make-array 16 :element-type 'character :fill-pointer 0 :adjustable t)))
  (apply #'svg-collect-transform *svg-transform-attribute* op args))

(defMethod context-save-view-transform ((context svg-context))
  (push-projection-variable #'(lambda (old-attribute)
                                (setq *svg-transform-attribute* old-attribute))
                            (shiftf *svg-transform-attribute* nil)))



:EOF
