;;; -*- Mode: LISP; Syntax: Common-lisp; Package: de.setf.object-graphics.implementation; Base: 10; Lowercase: Yes -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<DOCUMENTATION>
 <title>quickdraw</title>
 <DESCRIPTION>
  <p>
  defines the concrete implementation for graphics projection operations in
  terms of quickdraw functions.<br />
  the implementation evolved from a library which was single-targeted at
  quickdraw and supported specialization for functionality such as backing
  store and display-lists via methods for the individual operations. as dynamic
  projection contexts handle the variation a level up, this interface could be
  returned to the earlier simpler form.</p>
  </DESCRIPTION>
 <COPYRIGHT YEAR='2003' AUTHOR='james adam anderson' href='../load/sysdcl.lisp' />
 <CHRONOLOGY>
  <DELTA DATE='19880614' AUTHOR='jaa@dtmg' >
   as OG-graphics-standards, a preliminary version which does not take account
   of fill, invert, ... in polygon mode. this layer takes atomic parameters,
   rather than og-elements, since it is intended to be parallel to the lower
   level graphics with the addition of only coordinate system transformations.
   </DELTA>
  <DELTA DATE='19880625' AUTHOR='jaa@dtmg' >
   added coercion to point data in order to allow 4-d coordinate results from
   coordinate-transform also added functions for pictures, arcs.</DELTA>
  <DELTA DATE='19891113' AUTHOR='jaa@dtmg' >
   ported to clx/pcl; added polygon modes to arc function.</DELTA>
  <DELTA DATE='19940523' AUTHOR='jaa@dtmg' >
   took out direct toolbox calls and replaced them with methods in order to
   allow specializations (eg. for backing store).</DELTA>
  <DELTA DATE='20030905' AUTHOR='james.anderson@setf.de'>
   see the generic port-transform-context <a href='port-transform-context'>
   implementation</a>.</DELTA>
  <DELTA DATE='20030924'>eliminated :paint mode in favour of simpler :fill
   with distinction between fill-pattern and fill-color</DELTA>
  <DELTA DATE='20031002'>simplified further to just manifest modes (surfaces,
   lines, points) and effects (paint, erase, flip) using whatever is set
   for the manifestation agent - a color, or a pattern. the assertion methods
   do not write through to the port for foreground and background. they now
   defer for all and let the geometry method decide what to do with the
   current manifestation.</DELTA>
  <DELTA DATE='20050620' AUTHOR='janderson@ravenpack.com'/>
  <DELTA DATE='20051205' AUTHOR='janderson'> added funtion method to quickdraw-poly
   in order to gender graphs with more points than could oherwise appear in a poly.</DELTA>
  <DELTA DATE='20060425' AUTHOR='janderson'>clear disposed macptr values</DELTA>
  <DELTA DATE='20060925' AUTHOR='janderson'>corrected spelling for -agent operators</DELTA>
  </CHRONOLOGY>
 </DOCUMENTATION>


(in-package :de.setf.object-graphics.implementation)


;;;
;;; parameters

(defParameter *quickdraw-port* nil)

(defParameter *quickdraw-raster-operation* :srcCopy)


;;;
;;; the default agent values when establishing a quickdraw projection context

(defparameter *quickdraw-path-constituents* :lines
  "default quickdraw path constituents.
   used as the initial value when establishing a projection context.")

(defparameter *quickdraw-path-effect* :paint
  "default quickdraw paint effect. used as the initial value when establishing a projection context.")

(defparameter *quickdraw-path-rule* :winding
  "default quickdraw path rule.
   used as the initial value when establishing a projection context.")

(defparameter *quickdraw-foreground-agent* nil
  "caches the last set foreground color.")



;;;
;;;

(defmacro rlet-rgbcolor ((rgb r &optional g b) &rest body)
  "execute the body with a rgbcolr record bound and initialized to either three intensity values or the content of a fixnum vector."
  `(rlet ((,rgb :rgbcolor ,@(if g 
                              `(:red (if (integerp ,r) ,r (round (* ,r 65535.0)))
                                     :green (if (integerp ,g) ,g (round (* ,g 65535.0)))
                                     :blue (if (integerp ,b) ,b (round (* ,b 65535.0))))
                              `(:red (aref ,r 0) :green (aref ,r 1) :blue (aref ,r 2)))))
     ,@body))
(push '(rlet-rgbcolor . 1) ccl:*fred-special-indent-alist*)

(defmacro with-focused-gworld ((gworld expression) &body body)
  (let ((old-port   (gensym))
        (old-gdh    (gensym))
        (old-port-p (gensym))
        (old-gdh-p  (gensym)))
    `(let ((,gworld ,expression))
       (rlet ((,old-port-p :pointer)
              (,old-gdh-p  :pointer))
         (#_GetGWorld ,old-port-p ,old-gdh-p)
         (with-macptrs ((,old-port (%get-ptr ,old-port-p))
                        (,old-gdh  (%get-ptr ,old-gdh-p)))
           (unwind-protect
             (progn (#_SetGWorld ,gworld (%null-ptr))
                    ,@body)
             (#_SetGWorld ,old-port ,old-gdh)))))))

(defmacro with-locked-gworld-pixels ((&pixmap gworld) &body body)
  `(with-locked-pixels (,&pixmap (#_GetGWorldPixMap ,gworld)) ,@body))

(defmacro with-locked-pixels ((&pixmap expression) &body body)
  (let ((state (gensym)))
    `(let ((,&pixmap ,expression))
       (let ((,state (#_GetPixelsState ,&pixmap)))
         (unwind-protect
           (without-interrupts
             (when (#_LockPixels ,&pixmap)
               (progn ,@body))
             (#_SetPixelsState ,&pixmap ,state)))))))


;;;
;;; the quickdraw context class

(defClass quickdraw-context (port-transform-context single-sided-projection-context)
  ((arc-port :initform 'quickdraw-arc-port :allocation :instance)
   (line-port :initform 'quickdraw-line-port :allocation :instance)
   (raster-port :initform 'quickdraw-raster-port :allocation :instance)
   (rectangle-port :initform 'quickdraw-rectangle-port :allocation :instance)
   (text-port :initform 'quickdraw-text-port :allocation :instance))
  (:documentation
   ""))

(defclass quickdraw-projection-view (projection-view)
  ())


(defMethod call-with-projection-context
           ((function t) (context quickdraw-context)
            &key
            &allow-other-keys)
  (let* ((view (context-view context))
         (*context-path-constituents* *quickdraw-path-constituents*)
         (*context-path-effect* *quickdraw-path-effect*)
         (*context-path-rule* *quickdraw-path-rule*)
         (*context-clear-agent* nil)
         (*context-fill-agent* nil)
         (*context-stroke-agent* nil))
    (with-focused-view view
      (with-macptrs ((*quickdraw-port* (#_getwindowport (wptr view))))
        (unwind-protect 
          (rlet ((color :rgbcolor))
            (#_getportforecolor *quickdraw-port* color)
            (qd-fill-agent*3 (rref color :rgbcolor.red)
                                (rref color :rgbcolor.green)
                                (rref color :rgbcolor.blue))
            (qd-stroke-agent*3 (rref color :rgbcolor.red)
                                  (rref color :rgbcolor.green)
                                  (rref color :rgbcolor.blue))
            (#_getportbackcolor *quickdraw-port* color)
            (qd-clear-agent*3 (rref color :rgbcolor.red)
                                      (rref color :rgbcolor.green)
                                      (rref color :rgbcolor.blue))
            (call-next-method)))))))


  
(defMethod define-font ((context quickdraw-context) font-spec name)
  (multiple-value-bind (ff-code ms-code)
                       (ccl:font-codes font-spec)
    (setf (get-font context name) (list ff-code ms-code))
    name))

(defmethod context-view-p ((context quickdraw-context) (view view))
  (when (ccl:wptr view) t))


;;; 
;;; geometric elements
;;;
;;; these functions draw the basic geometric figures.
;;; they do not take structure objects, rather they require the explicit
;;; points - either as instances or as spread coordinates.
;;; all locations are location-vectors with port-coordinates.
                  
(defmethod context-path-agent ((context quickdraw-context) property)
  (etypecase property
    (vector property)
    (location-rgba property)
    (ccl:macptr property)
    (raster (context-raster-pixpat *projection-context* property))))


;;;
;;; line

(defun quickdraw-line-port (p-view location1 location2 aspects)
  "draw a line given the endpoints"
  (declare (type location-vector location1 location2))
  #-og.assert-types (declare (ignore p-view))
  #+og.assert-types (progn (assert-type p-view view)
                           (assert-types (location1 location2) location-vector)
                           (assert-type aspects (or list function)))
  (let ((x1 (%round (aref location1 0))) (y1 (%round (aref location1 1)))
        (x2 (%round (aref location2 0))) (y2 (%round (aref location2 1))))
    (flet ((line-geometry (path-agent path-constituents path-effect path-rule)
             (declare (ignore path-rule))
             (flet ((as-lines ()
                      (#_MoveTo x1 y1)
                      (#_LineTo x2 y2))
                    #+ignore (as-lines () x1 y1 x2 y2)
                    (as-points ()
                      (#_MoveTo x1 y1)
                      (#_LineTo x1 y1)
                      (#_MoveTo x2 y2)
                      (#_LineTo x2 y2)))
               (declare (dynamic-extent #'as-lines #'as-points))
               (ecase path-constituents
                 ((:surfaces :lines) (setf path-constituents #'as-lines))
                 (:points (setf path-constituents #'as-points)))
               (qd-foreground-color path-agent)
               (case path-effect
                 ((:clear :paint) (funcall path-constituents))
                 (:invert (rlet ((pen-state :penstate))
                          (#_GetPenState pen-state)
                          (#_PenMode #$srcXor)
                          (funcall path-constituents)
                          (#_SetPenState pen-state)))))))
      (declare (dynamic-extent #'line-geometry))
      (flet ((inflect-line-geometry () (call-with-path-properties #'line-geometry)))
        (declare (dynamic-extent #'inflect-line-geometry))
        (call-with-projection-variables #'inflect-line-geometry aspects)))))




;;;
;;; rectangle

(defun quickdraw-rectangle-port (p-view location1 location2 &optional aspects)
  (declare (type location-vector location1 location2))
  #-og.assert-types (declare (ignore p-view))
  #+og.assert-types (progn (assert-type p-view view)
                           (assert-types (location1 location2) location-vector)
                           (assert-type aspects sequence))
  (let ((x1 (%round (aref location1 0))) (y1 (%round (aref location1 1)))
        (x2 (%round (aref location2 0))) (y2 (%round (aref location2 1))))
    ;; double-check
    ;; (print (list (list x1 y1) (list x2 y2)))
    (when (< x2 x1) (rotatef x1 x2))
    (when (< y2 y1) (rotatef y1 y2))
    ;; (print (list (list x1 y1) (list x2 y2)))
    (rlet ((the-rect :rect :left (min x1 x2) :top (min y1 y2)
                     :bottom (max y1 y2) :right (max x1 x2)))
      (flet ((rectangle-geometry (path-agent path-constituents path-effect path-rule)
               (declare (ignore path-rule))
               (flet ((as-lines ()
                        (#_FrameRect the-rect))
                      (as-surfaces ()
                        (if (eq path-effect :invert)
                          (#_InvertRect the-rect)
                          (if (macptrp path-agent)
                            (#_FillCRect the-rect path-agent)
                            (#_PaintRect the-rect))))
                      (as-points () (#_moveTo x1 y1) (#_line 0 0)
                                    (#_moveTo x1 y2) (#_line 0 0) 
                                    (#_moveTo x2 y2) (#_line 0 0)
                                    (#_moveTo x2 y1) (#_line 0 0)))
                 (declare (dynamic-extent #'as-surfaces #'as-lines #'as-points))
                 (ecase path-constituents
                   (:surfaces (setf path-constituents #'as-surfaces))
                   (:lines (setf path-constituents #'as-lines))
                   (:points (setf path-constituents #'as-points)))
                 (qd-foreground-color path-agent)
                 (ecase path-effect
                   ((:clear :paint) (funcall path-constituents))
                   (:invert (rlet ((pen-state :penstate)) 
                            (#_GetPenState pen-state)
                            (#_PenMode #$srcXor)
                            (funcall path-constituents)
                            (#_SetPenState pen-state)))))))
        (declare (dynamic-extent #'rectangle-geometry))
        (flet ((inflect-rectangle-geometry () (call-with-path-properties #'rectangle-geometry)))
          (declare (dynamic-extent #'inflect-rectangle-geometry))
          (call-with-projection-variables #'inflect-rectangle-geometry aspects))))))


;;
;; polygon

(defun map-qd-polygon (function &polygon &optional count)
  (let* ((%polygon (%get-ptr &polygon))
         (point 0)
         (count (or count (rref %polygon polygon.polysize :storage :pointer))))
    (dotimes (i count)
      (setf point (rref %polygon (polygon.polypoints i) :storage :pointer))
      (funcall function point))
    (rref %polygon polygon.polysize :storage :pointer)))

(defmethod quickdraw-poly ((locations sequence) &optional aspects)
  (let ((get-next-location nil)
        (location-count (length locations))
        (last-index -1))
    (declare (type fixnum last-index location-count))
    (when (plusp location-count)
      (flet ((next-list-location ()
               (locally (declare (type list locations))
                 (pop locations)))
             (next-vector-location ()
               (locally (declare (type vector locations))
                 (when (< (incf last-index) location-count)
                   (aref locations last-index)))))
        (declare (dynamic-extent #'next-list-location #'next-vector-location))
        (etypecase locations
          (cons (setf get-next-location #'next-list-location))
          (vector (setf get-next-location #'next-vector-location)))
        (with-location-vectors ((port))
          (let ((x 0) (y 0) (port-x 0.0d0) (port-y 0.0d0) (location nil)
                (the-polygon nil)
                (state nil))
            (declare (dynamic-extent port-x port-y))
            (without-interrupts
             (unwind-protect
               (progn (unwind-protect
                        (progn (setf the-polygon (#_OpenPoly)
                                     state :started)
                               (typecase (setf location (funcall get-next-location))
                                 (fixnum (setf x (point-h location) y (point-v location)))
                                 (location-port (setf x (round (location-x location))
                                                      y (round (location-y location))))
                                 (t (location-transform *context-transform* location port)
                                    (setf port-x (aref port 0) port-y (aref port 1))
                                    (setf x (%round port-x) y (%round port-y))))
                               (#_MoveTo x y)
                               (loop (typecase (setf location (funcall get-next-location))
                                       (null (return))
                                       (fixnum (setf x (point-h location) y (point-v location)))
                                       (location-port (setf x (round (location-x location))
                                                            y (round (location-y location))))
                                       (t (location-transform *context-transform* location port)
                                          (setf port-x (aref port 0) port-y (aref port 1))
                                          (setf x (%round port-x) y (%round port-y))))
                                     (#_LineTo x y))
                               (setf state :finished))
                        ; (break "poly: ~s/~s, count ~s." state the-polygon last-index)
                        (case state
                          (:started (#_ClosePoly) (#_KillPoly the-polygon)
                                    (setf state nil the-polygon nil))
                          (:finished (#_ClosePoly))
                          (t nil)))
                      ; (break "poly closed: ~s." the-polygon)
                      (flet ((qd-poly-geometry (path-agent path-constituents path-effect path-rule)
                               (declare (ignore path-rule))
                               (flet ((as-lines () (#_FramePoly the-polygon))
                                      (as-surfaces () (if (macptrp path-agent)
                                                    (#_FillCPoly the-polygon path-agent)
                                                    (#_PaintPoly the-polygon)))
                                      (as-points ()
                                        (flet ((as-point (point)
                                                 (#_MoveTo (point-h point) (point-v point))
                                                 (#_Line 0 0)))
                                          (declare (dynamic-extent #'as-point))
                                          (map-qd-polygon #'as-point the-polygon location-count))))
                                 (declare (dynamic-extent #'as-surfaces #'as-lines #'as-points))
                                 (ecase path-constituents
                                   (:surfaces (setf path-constituents #'as-surfaces))
                                   (:lines (setf path-constituents #'as-lines))
                                   (:points (setf path-constituents #'as-points)))
                                 (qd-foreground-color path-agent)
                                 (ecase path-effect
                                   ((:clear :paint) (funcall path-constituents))
                                   (:invert (rlet ((pen-state :penstate))
                                              (#_GetPenState pen-state)
                                              (#_PenMode #$srcXor)
                                              (funcall path-constituents)
                                              (#_SetPenState pen-state)))))))
                        (declare (dynamic-extent #'poly-geometry))
                        (flet ((inflect-poly-geometry () (call-with-path-properties #'qd-poly-geometry)))
                          (declare (dynamic-extent #'inflect-poly-geometry))
                          (call-with-projection-variables #'inflect-poly-geometry aspects))))
                                     
               (when (and the-polygon (macptrp the-polygon))
                 (#_KillPoly the-polygon)
                 (setf the-polygon nil))))))))))

(defmethod quickdraw-poly ((locations function) &optional aspects)
  "render a polygon given functional generator.
   the argument function should itself accept a single argument, another
   function, which it calls with successive location values, after which it
   must return. the location stream is transformed into a quickdraw polygon,
   which is rendered according to the modes and aspects as the last step.
   the actual polygon does not contain all the model point, but only those which are required,
   given the port resolution. this meakes it possible to render larger models in a given window.
   eg, a 86,400 long sine curve required only 1,523 points in a 768-wide window.
   this matters because the polygon contains a (byte 16) length field, which is somehow
   interpreted such that only 2^14-1 points can appear."
  (with-location-vectors ((port))
    (let ((port-x 0.0d0) (port-y 0.0d0)       ; the transformed coordinates
          (the-polygon nil)                   ; the quickdraw polygon
          (state nil)                         ; nil, :started, :finished
          (delta-x 0) (delta-y 0)             ; accumulated deltas
          (last-x nil) (last-y nil)           ; most recent port coordinates
          (location-count 0))
      (declare (dynamic-extent port-x port-y)
               (type fixnum delta-x delta-y last-x last-y location-count))
      (flet ((qd-poly-generator (location &aux (x 0) (y 0))
               (typecase location
                 (fixnum (setf x (point-h location) y (point-v location)))
                 (location-port (setf x (round (location-x location))
                                      y (round (location-y location))))
                 (t (location-transform *context-transform* location port)
                    (setf port-x (aref port 0) port-y (aref port 1))
                    (setf x (%round port-x) y (%round port-y))))
               ;; compute the delta from the last plotted point. if in just 1 direction
               ;; don't draw it, just keep pushing the same way.
               (cond ((null last-x)
                      (#_MoveTo x y)
                      (incf location-count)
                      (setf delta-x 0 delta-y 0
                            last-x x last-y y))
                     (t
                      (let ((d-x (- x last-x))
                            (d-y (- y last-y)))
                        (cond ((or (and (zerop delta-x) (zerop d-x))
                                   (and (zerop delta-y) (zerop d-y)))
                               (incf delta-x d-x)
                               (incf delta-y d-y))
                              (t
                               (incf location-count)
                               (#_LineTo last-x last-y)
                               (setf delta-x d-x delta-y d-y))))
                      (setf last-x x last-y y)))))
        (declare (dynamic-extent #'qd-poly-generator))
        (without-interrupts
          (unwind-protect
            (progn (unwind-protect
                     (progn (setf the-polygon (#_OpenPoly)
                                  state :started)
                            (funcall locations #'qd-poly-generator)
                            (setf state :finished))
                     (case state
                       (:started (#_ClosePoly) (#_KillPoly the-polygon)
                                 (setf state nil the-polygon nil))
                       (:finished (cond (last-x
                                         (incf location-count)
                                         (#_LineTo last-x last-y)
                                         (#_ClosePoly))
                                        ((plusp location-count)
                                         (cerror "continue." "inconsistent location count."))))
                       (t nil)))
                   ; (break "poly closed: ~s." the-polygon)
                   (flet ((qd-poly-geometry (path-agent path-constituents path-effect path-rule)
                            (declare (ignore path-rule))
                            (flet ((as-lines () (#_FramePoly the-polygon))
                                   (as-surfaces () (if (macptrp path-agent)
                                                     (#_FillCPoly the-polygon path-agent)
                                                     (#_PaintPoly the-polygon)))
                                   (as-points ()
                                     (flet ((as-point (point)
                                              (#_MoveTo (point-h point) (point-v point))
                                              (#_Line 0 0)))
                                       (declare (dynamic-extent #'as-point))
                                       (map-qd-polygon #'as-point the-polygon location-count))))
                              (declare (dynamic-extent #'as-surfaces #'as-lines #'as-points))
                              (ecase path-constituents
                                (:surfaces (setf path-constituents #'as-surfaces))
                                (:lines (setf path-constituents #'as-lines))
                                (:points (setf path-constituents #'as-points)))
                              (qd-foreground-color path-agent)
                              (ecase path-effect
                                ((:paint :clear) (funcall path-constituents))
                                (:invert (rlet ((pen-state :penstate))
                                         (#_GetPenState pen-state)
                                         (#_PenMode #$srcXor)
                                         (funcall path-constituents)
                                         (#_SetPenState pen-state)))))))
                     (declare (dynamic-extent #'poly-geometry))
                     (flet ((inflect-poly-geometry () (call-with-path-properties #'qd-poly-geometry)))
                       (declare (dynamic-extent #'inflect-poly-geometry))
                       (call-with-projection-variables #'inflect-poly-geometry aspects))))
            (when (and (plusp location-count) the-polygon (macptrp the-polygon))
              (#_KillPoly the-polygon)
              (setf the-polygon nil)))))
      location-count)))


(defMethod context-poly ((context quickdraw-context) locations &optional variables)
  "transform a setf of points to port coordinates and render a polygon.
   this is intended to be called as part of display list processing, which means that the view/port
   are already focused."
  (quickdraw-poly locations variables))


;;;
;;; arc

(defun quickdraw-arc-port (p-view location radius start end direction &optional (variables nil))
  "draw a rectangle given the 2d coordinates"
  (declare (type location-vector location))
  #-og.assert-types (declare (ignore p-view))
  #+og.assert-types (progn (assert-type p-view view)
                           (assert-type location location-vector)
                           (assert-types (radius start end) number)
                           (assert-type variables (or sequence function)))
  (unless (typep start 'double-float) (setf start (coerce start 'double-float)))
  (unless (typep end 'double-float) (setf end (coerce start 'double-float)))
  (let ((x (%round (aref location 0))) (y (%round (aref location 1)))
        (start-degrees 0.0d0) (end-degrees 0.0d0) (start-degrees-f 0) (end-degrees-f 0) (delta-f 0))
    (declare (type double-float start-degrees end-degrees)
             (dynamic-extent  start-degrees end-degrees))
    (etypecase radius
      (float (setf radius (round radius)))
      (fixnum ))
    ;; translate to degrees with origin @12 o'clock v/s radians @3
    (setf start-degrees (radians-to-degrees start)
          end-degrees (radians-to-degrees end)
          start-degrees-f (%round start-degrees)
          end-degrees-f (%round end-degrees)
          delta-f (ecase direction
                    (:clockwise (+ (- end-degrees-f start-degrees-f) 360))
                    (:counterclockwise (- end-degrees-f start-degrees-f))))
    ;; (print (list start-degrees-f end-degrees-f delta-f direction))
    ;; nb. with-rectangle-arg fliped x/y for bottom right !half the time!
    (rlet ((the-rect :rect :left (- x radius) :top (- y radius)
                     :bottom (+ y radius) :right (+ x radius)))
      (flet ((arc-geometry (path-agent path-constituents path-effect path-rule)
               (declare (ignore path-rule))
               (flet ((as-lines ()  (#_FrameArc the-rect start-degrees-f delta-f))
                      (as-surfaces () (if (macptrp path-agent)
                                    (#_FillCArc the-rect start-degrees-f delta-f path-agent)
                                    (#_PaintArc the-rect start-degrees-f delta-f)))
                      (as-points (&aux xc yc) (#_moveTo x y) (#_line 0 0)
                                              (setf xc (round (+ x (* radius (cos start))))
                                                    yc (round (+ y (* radius (sin start)))))
                                              (#_moveTo xc yc)
                                              (#_line 0 0)
                                              (setf xc (round (+ x (* radius (cos end))))
                                                    yc (round (+ y (* radius (sin end)))))
                                              (#_moveTo xc yc)
                                              (#_line 0 0)))
                 (declare (dynamic-extent #'as-surfaces #'as-lines #'as-points))
                 (ecase path-constituents
                   (:surfaces (setf path-constituents #'as-surfaces))
                   (:lines (setf path-constituents #'as-lines))
                   (:points (setf path-constituents #'as-points)))
                 (qd-foreground-color path-agent)
                 (ecase path-effect
                   ((:clear :paint) (funcall path-constituents))
                   (:invert (rlet ((pen-state :penstate))
                              (#_GetPenState pen-state)
                              (#_PenMode #$srcXor)
                              (funcall path-constituents)
                              (#_SetPenState pen-state)))))))
        (declare (dynamic-extent #'arc-geometry))
        (flet ((inflect-arc-geometry () (call-with-path-properties #'arc-geometry)))
          (declare (dynamic-extent #'inflect-arc-geometry))
          (call-with-projection-variables #'inflect-arc-geometry variables))))))

;;;
;;; text

(defun quickdraw-text-port (p-view location text &optional (font nil) (aspects nil))
  #+og.assert-types (progn (assert-type p-view view)
                           (assert-type location location-vector)
                           (assert-type text string)
                           (assert-type aspects (or list function)))
  (let ((x (%round (aref location 0))) (y (%round (aref location 1))))
    (flet ((geometry ()
             (#_MoveTo x y)
             ;; use either the erase or the stroke agent - text is never manifested as a surface
             (qd-foreground-color (if (eq *context-path-effect* :erase)
                                    *context-clear-agent*
                                    *context-stroke-agent*))
             (write-string text p-view)))
      (declare (dynamic-extent #'geometry))
      (if (and font (setf font (get-font *projection-context* font)))
        (destructuring-bind (ff ms) font
          (ccl:with-font-codes ff ms (call-with-projection-variables #'geometry aspects)))
        (call-with-projection-variables #'geometry aspects)))))



;;;
;;; raster

(defun quickdraw-raster-port (p-view location1 location2 raster &optional properties)
  (declare (type location-vector location1 location2))
  #+og.assert-types (progn (assert-type p-view view)
                           (assert-types (location1 location2) location-vector)
                           (assert-type properties sequence))
  (let* ((left (%round (aref location1 0)))
         (bottom (%round (aref location1 1)))
         (right (%round (aref location2 0)))
         (top (%round (aref location2 1)))
         (offset (port-offset raster))
         (gworld (sample-projection raster *projection-context*)))
    (when (< right left) (rotatef left right))
    (when (> top bottom) (rotatef bottom top))
    ;; (print (list left top right bottom))
    (rlet ((old-back :rgbcolor)
           (old-fore :rgbcolor)
           (white :rgbcolor :red #xffff :green #xffff :blue #xffff)
           (black :rgbcolor :red 0 :green 0 :blue 0))
      (unwind-protect
        (with-rectangle-arg (dest-rect left top right bottom)
          (#_OffsetRect dest-rect (point-h offset) (point-v offset))

          (with-rectangle-arg (src-rect (make-point 0 0) (sample-size raster))
            (let* ((dest-bitmap (#_GetPortBitMapForCopyBits (#_GetWindowPort (wptr p-view)))))
              ; (fresh-line)
              ; (print-record (#_GetPortBitMapForCopyBits gworld) :pixmap)
              ; (fresh-line)
              ; (print-record dest-bitmap :pixmap)
              (#_RGBBackColor black)
              (#_RGBForeColor white)
              (flet ((raster ()
                       (#_LockPixels (#_GetGWorldPixMap gworld))
                       (#_LockPixels dest-bitmap)
                       (#_CopyBits (#_GetPortBitMapForCopyBits gworld)  ; using GetPort() here fails
                        dest-bitmap src-Rect dest-Rect #$srcCopy (%null-ptr))
                       (#_UnlockPixels (#_GetGWorldPixMap gworld))
                       (#_UnlockPixels dest-bitmap)
                       ))
                (declare (dynamic-extent #'raster))
                (call-with-projection-variables #'raster properties)))))
        (#_RGBBackColor old-back)
        (#_RGBForeColor old-fore)
        ))))
              




(defMethod terminate-relation ((owner raster) (key (eql :pixmap)) pixmap)
  (when (and (macptrp pixmap) (not (ccl:%null-ptr-p pixmap)))
    (#_DisposePixmap pixmap)
    (ccl:%setf-macptr pixmap (ccl:%null-ptr))))

(defMethod terminate-relation ((owner raster) (key (eql :gworld)) gworld)
  (when (and (macptrp gworld) (not (ccl:%null-ptr-p gworld))) 
    (#_DisposeGWorld gworld)
    (ccl:%setf-macptr gworld (ccl:%null-ptr))))

(defmethod sample-introjection ((raster raster) (context quickdraw-context))
  )

(defmethod sample-projection ((raster raster) (context quickdraw-context))
  (let ((sample-projection (context-get context :gworld raster)))
    (unless (and sample-projection
                 (test-projection-generation raster context))
      (let* ((size (sample-size raster))
             (depth (sample-depth raster))
             (sample-data (sample-data raster))
             (bytes-per-pixel (/ depth 8))
             (sample 0)
             (gworld nil)
             (&pixmap nil)
             (pixmap-baseaddr nil)
             (pixmap-offset 0)
             (bytes-per-row 0))
        (rlet ((sample-rectangle :rect :topleft (make-point 0 0) :bottomright size)
               (&gworld :handle))
          (cond (sample-projection
                 (setf gworld sample-projection))
                (t
                 (assert (zerop (#_NewGWorld &gworld depth sample-rectangle (%null-ptr) (%null-ptr) 0)))
                 (setq gworld (%get-ptr &gworld))))
          (setq &pixmap (#_GetGWorldPixMap gworld))
          (assert (#_LockPixels &pixmap))
          (with-dereferenced-handles ((pixmap &pixmap))
            (assert (not (%null-ptr-p pixmap)))
	    (setf pixmap-baseaddr (#_GetPixBaseAddr &pixmap))
            (setf bytes-per-row (#_GetPixRowBytes &pixmap)))
          
          (dotimes (i (point-v size))
            (setf pixmap-offset (* i bytes-per-row))
            (dotimes (j (point-h size))
              (setf sample (sample-filter raster (aref sample-data i j) i j))
              (case depth
                (8 (%put-byte pixmap-baseaddr sample pixmap-offset))
                (16 (%put-word pixmap-baseaddr sample pixmap-offset))
                (32 (%put-long pixmap-baseaddr sample pixmap-offset)))
              (incf pixmap-offset bytes-per-pixel)))
          
          (#_UnlockPixels &pixmap)
          (set-projection-generation raster context)
          (setf sample-projection gworld)
          (setf (context-get context :gworld raster) gworld))))
    sample-projection))


(defMethod sample-load-image ((raster raster) (context quickdraw-context) (source pathname))
  (let ((gworld (quickdraw-load-image source)))
    (when gworld
      (setf (context-get context raster :gworld) gworld))
    gworld))

(defun quickdraw-load-image (pathname &key (type (intern (string-upcase (pathname-type pathname)) :keyword)))
  (ecase type
    ((:jpeg jpg) (quickdraw-load-jpeg-image pathname))))


(defun quickdraw-load-jpeg-image (pathname) 
  (labels ((make-image-buffer (size)
             ;; Allocate a memory block with the given size.
             (let ((buffer (#_NewHandle size)))                           ; allocate a handle buffer 
               (if buffer                                                     ; if buffer
                 buffer                                                       ; return a handle/pointer                                    
                 (progn                                                       ; else
                   (let ((err (#_MemError)))                                  ; call the MemError
                     (declare (dynamic-extent err))
                     (error "Unable to allocate a buffer.(~a)" err))          ; show the error
                   nil))))
           (load-data (image-file)
             (with-slots (ccl::file-name) image-file
               (with-FSOpen-file (pb ccl::file-name)                                  ; open the file
                 (let* ((size (GetEOF pb))                                       ; get the length of the file
                        (&buffer (make-image-buffer size)))                  ; allocate a buffer to read
                   (when &buffer                                                  ; if allocated
                     (with-dereferenced-handles ((buffer &buffer))
                       (without-interrupts
                         (FSRead pb size buffer)                                   ; read all data to it
                         &buffer)))))))
           (make-image-description (image-file)
             (with-slots (ccl::image-width ccl::image-height) image-file
               (let ((&desc (make-record (:ImageDescription :storage :handle))))
                 (setf (href &desc :ImageDescription.idSize) (record-length :ImageDescription)
                       (href &desc :ImageDescription.width)  ccl::image-width
                       (href &desc :ImageDescription.height) ccl::image-height
                       (href &desc :ImageDescription.temporalQuality) 0
                       (href &desc :ImageDescription.spatialQuality) #$codecHighQuality
                       (href &desc :ImageDescription.dataSize) 0
                       (href &desc :ImageDescription.frameCount) 1
                       (href &desc :ImageDescription.cType) :|jpeg|
                       (href &desc :ImageDescription.version) 0
                       (href &desc :ImageDescription.revisionLevel) 0
                       (href &desc :ImageDescription.vendor) 0
                       (href &desc :ImageDescription.hRes) (ccl::get-qd-hRes image-file)
                       (href &desc :ImageDescription.vRes) (ccl::get-qd-vRes image-file)
                       (href &desc :ImageDescription.depth) (ccl::get-qd-pixel-depth image-file)
                       (href &desc :ImageDescription.clutId) -1
                       (href &desc :imageDescription.name) "jpeg")
                 &desc)))
           (make-jpeg-file (pathname)
             (let ((image-file (make-instance 'ccl::jpeg-file :file-name pathname)))
               (when (ccl::scan-image-file image-file)
                 image-file))))
    (let* ((image-file (make-jpeg-file pathname))
           (&buffer (when image-file (load-data image-file)))
           (&description (when image-file (make-image-description image-file))))
      (unwind-protect
        (when &description
          ; (print-record &description :ImageDescription)

          (rlet ((image-rectangle :rect :topleft (make-point 0 0) :bottomright (ccl::get-image-size image-file))
                 (&gworld :handle))
            ; (print (list :depth (ccl::get-qd-pixel-depth image-file)))
            (unless (zerop (#_NewGWorld &gworld (ccl::get-qd-pixel-depth image-file)
                            image-rectangle (%null-ptr) (%null-ptr) 0))
              (error "can't create gworld."))
            (with-focused-gworld (gworld (%get-ptr &gworld))
              (with-locked-gworld-pixels (&pixmap gworld)
                (with-dereferenced-handles ((buffer &buffer))
                  (let ((err (#_DecompressImage         ; call FDecompressImage
                              buffer                    ; pointer to JPEG data
                              &description              ; Description handle
                              &pixmap                   ; destination pixmap handle
                              image-rectangle           ; source rect
                              image-rectangle                 ; the rect image is decompressed to
                              #$ditherCopy                          ; transfer mode
                              (%null-ptr))))                        ; mask
                    ; (print (list :err err))
                    (unless (zerop err)
                      (return-from quickdraw-load-jpeg-image nil))

                    )))
              gworld)))
        (progn                          ; unwind
          (when &buffer (#_DisposeHandle &buffer))
          (when &description (dispose-record &description :handle)))))))



;;; general utilities
;;;

(defun quickdraw-fill-view (view agent)
  (with-rectangle-arg (the-rect (make-point 0 0) (view-size view))
    (etypecase agent
      (ccl::macptr
       (#_FillCRect the-rect agent))
      ((member t)
       (#_PaintRect the-rect))
      ((or cons location-3 vector raster)
       (with-projection-variables (lambda () (stroke-agent agent))
         (qd-foreground-color *context-stroke-agent*)
         (#_PaintRect the-rect))))))


(defMethod context-clear-view ((context quickdraw-context))
  (quickdraw-fill-view (context-view context) *context-clear-agent*))


(defMethod context-fill-view ((context quickdraw-context) &optional (agent *context-fill-agent*))
  (quickdraw-fill-view (context-view context) agent))

(defmethod context-flush-view ((context quickdraw-context))
  nil)


;;;
;;; display manifestations

;;;
;;; generation and caching for quickdraw-specific representations

(defMethod context-raster-pixpat ((context quickdraw-context) raster)
  (or (context-get context :pixpat raster)
      (let ((&pixmap (context-raster-pixmap context raster))
            (&pixpat (#_newPixpat)))
        (pixmap-to-pixpat &pixmap &pixpat)
        (setf (context-get context raster :pixpat) &pixpat))))

(defMethod context-raster-pixmap ((context quickdraw-context) raster)
  (or (context-get context raster :pixmap)
      (setf (context-get context :pixmap raster)
            (compute-raster-pixmap raster))))

(defun raster-to-pixmap (raster &pixmap)
  "modify a pixmap to represent the data from a raster. the pixmap is resized accoding to the raster bounds an provided with a new _handle_ filtered sample data."
  (let* ((%pixmap (%get-ptr &pixmap))
         (%pixmap-baseaddr nil)
         (%gworld nil)
         (&gworld-pixmap nil)
         (%gworld-baseaddr nil)
         (sample-size (sample-size raster))
         (sample-depth (sample-depth raster))
         (bytes-per-pixel (/ sample-depth 8))
         (bytes-per-row (* (point-v sample-size) bytes-per-pixel)))
    (setf %pixmap-baseaddr (rref %pixmap pixmap.baseaddr :storage :pointer))
    (when (and (macptrp %pixmap-baseaddr) (not (%null-ptr-p %pixmap-baseaddr)))
      (#_DisposeHandle %pixmap-baseaddr)
      (setf %pixmap-baseaddr (%null-ptr))
      (setf (rref %pixmap pixmap.baseaddr :storage :pointer) %pixmap-baseaddr))
    
    (rlet ((sample-rectangle :rect :topleft (make-point 0 0) :bottomright sample-size)
           (&gworld :handle))
      (assert (zerop (#_NewGWorld &gworld sample-depth sample-rectangle (%null-ptr) (%null-ptr) 0)))
      (setf %gworld (%get-ptr &gworld))
      (setf &gworld-pixmap (#_GetGWorldPixMap %gworld))
      (assert (#_LockPixels &gworld-pixmap))
      (with-dereferenced-handles ((%pixmap &gworld-pixmap))
        (assert (not (%null-ptr-p %pixmap)))
        (setf %gworld-baseaddr (#_GetPixBaseAddr &gworld-pixmap))
        (setf bytes-per-row (#_GetPixRowBytes &gworld-pixmap)))
      (let ((sample-data (sample-data raster))
            (sample 0)
            (pixmap-offset 0))
        (dotimes (i (point-v sample-size))
          (setf pixmap-offset (* i bytes-per-row))
          (dotimes (j (point-h sample-size))
            (setf sample (sample-filter raster (aref sample-data i j) i j))
            (case sample-depth
              (8 (%put-byte %gworld-baseaddr sample pixmap-offset))
              (16 (%put-word %gworld-baseaddr sample pixmap-offset))
              (32 (%put-long %gworld-baseaddr sample pixmap-offset)))
            (incf pixmap-offset bytes-per-pixel)))))
    (#_CopyPixmap &gworld-pixmap &pixmap)
    #|; this was leaving both the original and the new with the same data handle
     (let ((data-length (* (point-v sample-size) bytes-per-row)))
      (rlet ((&&baseaddr :handle))
        (#_PtrToHand %gworld-baseaddr &&baseaddr data-length)
        (setf (rref %pixmap pixmap.baseaddr :storage :pointer) (%get-ptr &&baseaddr))))|#
    (let* ((data-length (* (point-v sample-size) bytes-per-row))
           (&baseaddr (#_NewHandle data-length))
           (%baseaddr (%get-ptr &baseaddr)))
      (#_BlockMove %gworld-baseaddr %baseaddr data-length)
      (setf (rref %pixmap pixmap.baseaddr :storage :pointer) &baseaddr))
    (#_UnlockPixels &gworld-pixmap)
    (#_DisposeGworld %gworld)
    &pixmap))


(defun pixmap-to-pixpat (&pixmap &pixpat)
  (#_LockPixels &pixmap) 
  (let* ((%pixmap (%get-ptr &pixmap))
         (%pixmap-bounds (rref %pixmap pixmap.bounds :storage :pointer))
         (%pixpat (%get-ptr &pixpat))
         (&pixpat-pixmap (#_NewPixmap)))
    (unless (%null-ptr-p (rref %pixpat pixpat.patMap :storage :pointer))
      (#_disposePixMap (rref %pixpat pixpat.patMap :storage :pointer)))
    (setf (rref %pixpat pixpat.patType :storage :pointer) 1)
    (setf (rref %pixpat pixpat.patMap :storage :pointer) &pixpat-pixmap)
    (#_CopyPixmap &pixmap &pixpat-pixmap)
    (let* ((data-length (* (#_GetPixRowBytes &pixmap)
                           (- (rref %pixmap-bounds rect.bottom)
                              (rref %pixmap-bounds rect.top))))
           (%data (#_NewPtr data-length))
           ;; data is a handle as for ofscreen gworlds
           (%baseaddr (#_GetPixBaseAddr &pixmap))
           )
      (#_BlockMove %baseaddr %data data-length)
      (setf (rref %pixpat pixpat.patdata :storage :pointer) %data))
    (#_PixPatChanged &pixpat)
    (#_UnlockPixels &pixmap)
    &pixpat))

(defMethod compute-raster-pixmap ((raster raster))
  "given a raster, make a pixpat which encapsulates the pixmap data."
  (let* ((&pixmap (#_NewPixmap))
         (%pixmap (%get-ptr &pixmap)))
    ;; maintain handle-or-null field type
    (#_DisposePtr (rref %pixmap pixmap.baseaddr :storage :pointer))
    (setf (rref %pixmap pixmap.baseaddr :storage :pointer) (%null-ptr))
    (raster-to-pixmap raster &pixmap)))

(defMethod compute-raster-pixpat ((raster raster))
  "given a raster, make a pixpat which encapsulates the pixmap data for use as a pen or foll pattern."
  (pixmap-to-pixpat (compute-raster-pixmap raster) (#_NewPixpat)))


;;; properties
;;;
;;; manifest {<form> <form-attributes>}* is destructured and delegated abstractly
;;; manifest-<form> <form-attributes>
;;; manifest-<form>-<attribute> <attribute-values>

(defmethod context-normalized-path-constituents
           ((context quickdraw-context) (front symbol) (back t))
  (declare (ignore back))
  front)

(macrolet ((define-agent (stem)
             (setf stem (string stem))
             (let ((typed-set-function (intern (concatenate 'string (string :QD-) stem (string :-agent*3))))
                   (generic-set-function (intern (concatenate 'string (string :context-set-) stem (string :-agent))))
                   (save-function (intern (concatenate 'string (string :context-save-) stem (string :-agent))))
                   (method*3 (intern (concatenate 'string (string :context-) stem (string :-agent*3))))
                   (method*4 (intern (concatenate 'string (string :context-) stem (string :-agent*4))))
                   (context-var (intern (concatenate 'string (string :*context-) stem (string :-agent*))))
                   (restore-function (intern (concatenate 'string (string :QD-restore-) stem (string :-agent)))))
               `(progn
                  (defun ,typed-set-function (r g b)
                    ;; makes a new color vector and binds it to both the context variable
                    ;; and the quickdraw-specific variable
                    (with-fixnum-intensity-variables (r g b)
                      (setq ,context-var (get-fixnum-location-vector))
                      (setf (aref ,context-var 0 ) r
                            (aref ,context-var 1 ) g
                            (aref ,context-var 2 ) b)
                      ,context-var))
                  
                  (defMethod ,method*3 ((context quickdraw-context) r g b)
                    (,typed-set-function r g b))
                  
                  (defMethod ,method*4 ((context quickdraw-context) r g b &optional a)
                    ; optional to allow call from agent w/o length check
                    (declare (ignore a))
                    (,typed-set-function r g b))
                  
                  (defMethod ,generic-set-function  ((context quickdraw-context) color &optional g b a)
                    "examine the arguments to distinguish rgb intensities
                     (spread or as location) from a raster pattern, and a
                     symbolic color designator."
                    (declare (ignore a))
                    (etypecase color
                      (number
                       (,typed-set-function color g b))
                      (cons
                       (destructuring-bind (r g b &optional a) (if (symbolp (first color)) (rest color) color)
                         (declare (ignore a))
                         (,typed-set-function r g b)))
                      ((or vector location-2)  ; also applies to location-rgba
                       (with-location-coordinates (((r g b) color))
                         (,typed-set-function r g b)))
                      (raster
                       (setf ,context-var (context-raster-pixpat *projection-context* color)))
                      (symbol
                       ;; reuse the other color values.
                       (case color
                         (:stroke (,generic-set-function context *context-stroke-agent*))
                         (:fill (,generic-set-function context *context-fill-agent*))
                         (:clear (,generic-set-function context *context-clear-agent*))
                         (t (if (and (boundp color)
                                       (not (eq color (setq color (symbol-value color)))))
                              (,generic-set-function context color)
                              (error "invalid agent: ~s" color)))))))
                  (defun ,restore-function (context agent-designator)
                    (,generic-set-function context agent-designator)
                    (if (fixnum-location-vector-p agent-designator)
                      (return-short-location-vector agent-designator)))
                  (defMethod ,save-function ((context quickdraw-context))
                    "save the current agent. as these are supplied by the application, no resourcing is done"
                    (push-projection-variable #',restore-function context ,context-var))))))
  (define-agent fill)
  (define-agent stroke)
  (define-agent clear))

(defun qd-foreground-color (path-agent)
  ;; test against the last value set. if they differn then cache and set the new value
  (unless (equal path-agent *quickdraw-foreground-agent*)
    (setq *quickdraw-foreground-agent* path-agent)
    (etypecase path-agent
      (ccl:macptr (#_PenPixPat path-agent))
      (vector (rlet-rgbcolor (rgbColor path-agent)
                (#_rgbforecolor rgbColor)))
      (location (rlet-rgbcolor (rgbColor (rgba-r path-agent)
                                         (rgba-g path-agent)
                                         (rgba-b path-agent))
              (#_rgbforecolor rgbColor)))
      (fixnum (#_ForeColor path-agent)))))

;;;
;;; mode management is that of a single-sided-projection-context



;;;
;;; initialization

(qd-fill-agent*3 1.0 1.0 1.0)
(qd-stroke-agent*3 1.0 1.0 1.0)
(qd-clear-agent*3 0.0 0.0 0.0)


:eof

