;;; -*- Mode: LISP; Syntax: Common-lisp; Package: de.setf.object-graphics.implementation; Base: 10; Lowercase: Yes -*-

#|
<documentation>
 <title>library</title>
 <description>
  definitions various useful things</description>
 <chronology>
  <DELTA DATE='20030829' AUTHOR='jaa@setf.de'></DELTA>
  <DELTA DATE='20040228'>removed clas-slot-names to library</DELTA>
  </CHRONOLOGY>
 </DOCUMENTATION>
|#

(in-package :de.setf.object-graphics.implementation)

(defvar +2pi+ (* pi 2.0d0))

(defvar og::*version* 1.0)
(defun og::version () og::*version*)

(defVar *path-modes* '(:erase           ; fill with background or transparent
                       :eofill          ; fill with even/odd rule where supported, otherwise fill
                       :eofill-stroke   ; fill then stroke with e/o rule
                       :fill            ; fill with color/pattern
                       :fill-stroke     ; fill then stroke
                       :invert          ; invert
                       :point           ; render each vertex with the *path-vertex-aspects* function (where supported)
                       :stroke          ; stroke  with color/pattern
                       )
  "the abstract path mode designators. each concrete interface maps them to its own designators.")

(defun path-mode-p (x) (member x *path-modes*))

(unless (fboundp 'fixnump)
  (defun fixnump (x) (typep x 'fixnum)))

(defmacro assert-type (m type)
  "assert the type of the given variable. often used in combination with #+assert-types"
  (when (and (consp type) (eq (first type) 'quote)) (setf type (second type)))
  (labels ((try-predicate (suffix)
             (let ((symbol (find-symbol (concatenate 'string (string type) (string suffix)))))
               (when (and symbol (fboundp symbol))
                 symbol)))
           (make-predicate ()
             (or (and (symbolp type)
                      (or (let ((*package* (symbol-package type))) (or (try-predicate :-p) (try-predicate :p)))
                          (try-predicate :-p) (try-predicate :p)))
                 `(lambda (x) (typep x ',type)))))
    `(unless (,(make-predicate) ,m)
       (error "datum not of type ~s: ~s." ',type ,m))))

(defmacro assert-types (variables type)
  "assert the type of the given variables. often used in combination with #+assert-types"
  `(progn ,@(mapcar #'(lambda (v) `(assert-type ,v ,type)) variables)))

(defmacro defgraphicelement ((name (&key (include 'node))) &rest slots)
  "the defGraphicElement translates the older structure-oriented descriptions to CLOS defClass forms"
  `(defClass ,name (,include)
     ,(mapcar #'(lambda (slot-declaration)
                  (destructuring-bind (name initform &key type) slot-declaration
                    `(,name :initform ,initform :initarg ,(intern (string name) :keyword)
                            ,@(when type `(:type ,type)))))
              slots)))

(defun nyi-error (operator)
  (error "NYI: ~s: ~a / ~a."
         operator (lisp-implementation-type) (lisp-implementation-version)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defparameter *projection-monitor-function*
    (ignore-errors (and (find-package :rt)
                        (symbol-function
                         (find-symbol
                          (string :call-with-time-and-memory-counted) :rt))))
    "specifies a function designator to be used by projection operators to monitor
     their time and space usage. should be a function of one argument - #'call-next-method
     which returns three values - a value list, time usage and memory usage."))

#+ccl
(defmacro defrecord (&rest args)
  `(ccl:defrecord ,@args))

#-ccl
(defmacro defrecord (name &rest args)
  (declare (ignore args))
  `(nyi-error ',name))


:eof

