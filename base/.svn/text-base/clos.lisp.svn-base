;;; -*- Mode: lisp; Syntax: ansi-common-lisp; Base: 10; Package: de.setf.utility.implementation; -*-

(in-package :de.setf.utility.implementation)

(modPackage :setf.clos
  (:export
   :denominated-progn
   ))

(define-method-combination denominated-progn (&key (operator 'progn)
                                                   (qualifiers nil)
                                                   (order :most-specific-first)
                                                   (call-next-method-p t)
                                                   (if-not-applicable nil)
                                                   (verbose-p nil))
                           ((after (:after) :order :most-specific-last)
                            (around (:around) :order :most-specific-first)
                            (before (:before) :order :most-specific-first)
                            (between (:between) :order :most-specific-first)
                            (all-methods * :required t :order :most-specific-last))
  (:generic-function function)
  "combine all qualified methods. no unqualified method is permitted. the method qualifiers are arbitrary. the initial set of applicable methods, as sorted according to the combination's :order specification, is grouped by qualifier. the qualifier groups are then arranged as specified by the applicable qualifiers for the given function and arguments.
   for a given generic function definition, the qualifiers may be a literal list, or it may be a function designator. in the latter cases, the function is applied to a list* of the generic function and the specializers."
  (ecase if-not-applicable ((nil)) (:error))
  (ecase order (:most-specific-first ) (:most-specific-last ))
  (flet ((eliminate (these from)
           "in case * matches everything, nut just those unmatched by others"
           (dolist (this these) (setf from (remove this from)))
           from))
    (let ((primary (eliminate after (eliminate around (eliminate before (eliminate between all-methods)))))
          (grouped-methods nil)
          (group nil)
          (applicable-qualifiers nil)
          (method-qualifiers nil)
          (qualifier nil)
          (form nil)
          (first-group-p t))
      (unless primary
        (method-combination-error "no applicable primary methods for ~s." function))
      (when verbose-p
        (format t "~%:around: ~s~%:before: ~s~%primary: ~s~%:after: ~s" around before primary after))

      ;; collect the qualifier constraints for the given arguments and function
      ;; these are either a literal list, or generated for the specializers
      (setf applicable-qualifiers (etypecase qualifiers
                                    (cons
                                     qualifiers)
                                    ((or (and symbol (not null)) function)
                                     (apply qualifiers function (method-specializers (first (last all-methods)))))))
      (when verbose-p
        (format t "~%applicable qualifiers: ~s." applicable-qualifiers))

      ;; group the methods by applicable qualifier, result is least-specific-first within arbitrary specializer order
      ;; i considered allowing multiples when call-next-method-p was false, but there is no clear way to
      ;; handle multiples which are then superseded.
      (dolist (method primary)
        (setf method-qualifiers (method-qualifiers method))
        (cond ((= 1 (length method-qualifiers))
               (setf qualifier (first method-qualifiers))
               (if (or (member qualifier applicable-qualifiers) (find t applicable-qualifiers))
                 (cond ((setf group (assoc qualifier grouped-methods))
                        (push method (rest group)))
                       (t
                        (push (list qualifier method) grouped-methods)))
                 (when if-not-applicable
                   (invalid-method-error method "method qualifier not among those permitted: ~s." applicable-qualifiers))))
              (t
               (invalid-method-error method "method must have exactly one qualifier when call-next-method is allowed."))))

      ;; reverse groups if desired to get t groups back in most-specific-last order
      (when (eq order :most-specific-last)
        (setf grouped-methods (reverse grouped-methods)))
      ;; sort the groups by applicable qualifier
      (setf grouped-methods (stable-sort grouped-methods #'<
                                         :key #'(lambda (group) (or (position (first group) applicable-qualifiers)
                                                                    (position t applicable-qualifiers)
                                                                    (break "no position: ~s: ~s." qualifier applicable-qualifiers)))))
      (when verbose-p
        (format t "~%grouped ~:w" grouped-methods))
      
      (flet ((call-method-group (method-group &aux call)
               (destructuring-bind (qualifier . methods) method-group
                 ;; reverse them if desired to get the most specific methods within each group last
                 (declare (ignore qualifier))
                 (when (eq order :most-specific-last) (setf methods (reverse methods)))
                 (setf call `(call-method ,(first methods) ,(rest methods)))
                 (if first-group-p
                   (setf first-group-p nil)
                   (when between
                     (setf call `(progn (call-method ,(first between) ,(when call-next-method-p (rest between)))
                                        ,call))))
                 call))
             (call-methods (methods)
               (mapcar #'(lambda (method) `(call-method ,method)) methods)))
        (setf form
              (if (rest grouped-methods)
                ;; if there is more than one group, combine them with the operator.
                `(,operator ,@(mapcar #'call-method-group grouped-methods))
                (call-method-group (first grouped-methods))))
        (when before (setf form `(progn ,@(call-methods before) ,form)))
        (when after (setf form `(multiple-value-prog1 ,form ,@(call-methods after)))))

      (when around
        (setf form `(call-method ,(first around)
                                 (,@(rest around)
                                  (make-method ,form)))))

      (when verbose-p
        (pprint form))
      
      form)))