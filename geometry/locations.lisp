;;; -*- Mode: LISP; Syntax: Common-lisp; Package: de.setf.graphics.implementation; Base: 10; Lowercase: Yes -*-

(in-package :de.setf.graphics.implementation)

(document "This file defines location classes for the 'de.setf.graphics' library."

  (copyright "Copyright 2010 [james anderson](mailto:james.anderson@setf.de) All Rights Reserved"
             "'de.setf.graphics' is free software: you can redistribute it and/or modify it under the terms of version 3
  of the GNU Affero General Public License as published by the Free Software Foundation.

  'de.setf.graphics' is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the Affero General Public License for more details.

  A copy of the GNU Affero General Public License should be included with 'de.setf.graphics' as `agpl.txt`.
  If not, see the GNU [site](http://www.gnu.org/licenses/).")

  (history
   (delta 20090331 "corrected type error in location-h")
   (delta 20061015 "added color names") 
   (delta 20060928 "format-location")
   (delta 20051207 "added optional initial values to location-vector constructor.")
   (delta 20040122 "changes to meta syntax")
   (delta 20030829 "jaa@setf.de"
          "simplified accessor names, meta-based parser, unified interface to fixnum/structure/sequence
    locations")
   (delta 19891201 "jaa@dtmg" "added location-4 for ray-tracing/acoustic simulation")
   (delta 19891106 "jaa@dtmg" "ported to franz/pcl - didn't require any changes.
    retained the primitive-datum code for future use.")
   (delta 19880829 "jaa@dtmg" "exported location-2, -3 functions")
   (delta 19880628 "jaa@dtmg" "reduced the classes to point, location-2, location-3
    with world, object, port, ndc all inheriting from location-3")
   (delta 19880401 "jaa@dtmg" "added read and write functions for location structures
    modified arithmetic operations so that thay will take
    a combination of number and location args
    introduced separate layers for uncoerced and coerced args
    most expect to be called with locations or single-valued
    data. the transformation operations are unique in that they
    may also be called with interval data, since they will
    not be called through the interval math package.")
   (delta 19880016 "jaa@dtmg" "rewrote for use with the simpler object graphics system
    removed location math and transform function to separate
   files (OG-location-transform, OG-location-math)")
   (delta 19870917 "mdg@dtmg" "port to clos;
   changed OWNP to BOUNDP in COERCE-TO-location")
    (delta 19870907 "mdg@dtmg" "added location-abs") 
   (delta 19870701 "jaa@dtmg"))

  (long-description
   "Define location classes for geometric scene model, color spaces, and graphics rendering.

 The model levels distinguish
 object, world, ndc, and port coordinate domains. All are represented as structures with respective
 coordinate values. In the first two systems, the values are double-float, in the ndc system they are
 single-float and in the port system they are fixnum. THis corresponds to the coordinate value domains
 for rendering libraries.
  The lisp runtimes are permitted lee-way in which floating point forms the support. Observations with

    (mapcar #'type-of  '(1.0f0 1.0d0 1.0s0 1.0l0))
  indicate that sbcl, mcl, and clozure agree on

    (SINGLE-FLOAT DOUBLE-FLOAT SINGLE-FLOAT DOUBLE-FLOAT)

  In which case, the concrete types single-float and double-float are used."))



(defmacro check-type-match (d1 d2)
  `(if (not (or (typep ,d1 (type-of ,d2)) (typep ,d2 (type-of ,d1))))
     (warn "type of ~a and ~a not matched." ,d1 ,d2)))


(document "location definitions"
  "note that the generic types do not specify component data type. this
permits them to accept any data, eg. justified, and interval data.
the named types port,ndc,world,object are specific and the constructors
coerce constituent values. this permits combination functions to presume
accessors types. spehrical and polar types establish no constraints.
the types are described in the respective documentation.
note that there is no generic double-float type, as the ensuing typecases
are at least as efficient with an (or location-world location-object)
as with a single general type.")


(eval-when (:compile-toplevel :load-toplevel :execute)
  ;; coerce all constituent on construction. otherwise the transformations
  ;; need to doublecheck all values
  (macrolet ((2df (x) `(etypecase ,x (double-float ,x) (number (float ,x 1.0d0))))
             (2sf (x) `(etypecase ,x (single-float ,x) (number (float ,x 1.0s0))))
             (2int (x) `(etypecase ,x (integer ,x) (number (round ,x)))))

    ;;;; sub-types for each level of dimensionality
    (defstruct (location-2 
                (:print-function print-location)
                (:conc-name :%location-2-)
                (:constructor location-2 (&optional x y h)))
      (x 0.0d0) (y 0.0d0) (h 1.0d0))
    (defun make-location-2 (&key (x 0.0d0) (y 0.0d0) (h 0.0d0))
      (location-2 x y h))

    (defstruct (location-3 
                (:print-function print-location)
                (:include  location-2)
                (:conc-name %location-3-)
                (:constructor location-3 (&optional x y z h)))
      (z 0.0d0))
    (defun make-location-3 (&key (x 0.0d0) (y 0.0d0) (z 0.0d0) (h 0.0d0))
      (location-3 x y z h))

    (defstruct (location-4 
	        (:print-function print-location)
	        (:include  location-3)
                (:conc-name %location-4-)
                (:constructor location-4 (&optional x y z time h)))
      (time 0.0d0))
    (defun make-location-4 (&key (x 0.0d0) (y 0.0d0) (z 0.0d0) (time 0.0d0) (h 0.0d0))
      (location-4 x y z time h))
    
    (defun %location-x (l) (%location-2-x l))
    (defun %location-y (l) (%location-2-y l))
    (defun %location-z (l) (%location-3-z l))
    (defun %location-h (l) (%location-4-h l))
    (defun (setf %location-x) (v l) (setf (%location-2-x l) v))
    (defun (setf %location-y) (v l) (setf (%location-2-y l) v))
    (defun (setf %location-z) (v l) (setf (%location-3-z l) v))
    (defun (setf %location-h) (v l) (setf (%location-4-h l) v))
    
    ;;;; subtypes for different location systems
    (defstruct (location-port 
                (:print-function print-location)
                (:include location-3)
                (:conc-name %location-port-)
                (:constructor %location-port (x y z h)))        ; nb. does have a 'z' and an 'h'
      "a location port is a location-3 which constrains x,y,z,h to the integer domain")
    (defun location-port (&optional (x 0) (y 0) (z 0) (h 0))
      (%location-port (2int x) (2int y) (2int z) (2int h)))
    (defun make-location-port (&key (x 0) (y 0) (z 0) (h 0))
      (%location-port (2int x) (2int y) (2int z) (2int h)))

    (defstruct (location-ndc 
                (:print-function print-location)
                (:include location-3)
                (:conc-name %location-ndc-)
                (:constructor %location-ndc (x y z h)))
      "a location ndc is a location-3 which constrains x,y,z,h to the short-float domain")
    (defun location-ndc (&optional (x 0.0s0) (y 0.0s0) (z 0.0s0) (h 0.0s0))
      (%location-ndc (2sf x) (2sf y) (2sf z) (2sf h)))
    (defun make-location-ndc (&key (x 0.0s0) (y 0.0s0) (z 0.0s0) (h 0.0s0))
      (%location-ndc (2sf x) (2sf y) (2sf z) (2sf h)))

    (defstruct (location-world 
                (:print-function print-location)
                (:include location-3)
                (:conc-name %location-world-)
                (:constructor %location-world (x y z h)))
      "a location-world is a location-3 which constrains x,y,z,h to the double-float domain")
    (defun location-world (&optional (x 0.0d0) (y 0.0d0) (z 0.0d0) (h 0.0d0))
      (%location-world (2df x) (2df y) (2df z) (2df h)))
    (defun make-location-world (&key (x 0.0d0) (y 0.0d0) (z 0.0d0) (h 0.0d0))
      (%location-world (2df x) (2df y) (2df z) (2df h)))

    (defstruct (location-object 
                (:print-function print-location)
                (:include location-3)
                (:conc-name %location-object-)
                (:constructor %location-object (&optional x y z h)))
      "a location-object is a location-3 which constrains x,y,z,h to the double-float domain")
    (defun location-object (&optional (x 0.0d0) (y 0.0d0) (z 0.0d0) (h 0.0d0))
      (%location-object (2df x) (2df y) (2df z) (2df h)))
    (defun make-location-object (&key (x 0.0d0) (y 0.0d0) (z 0.0d0) (h 0.0d0))
      (%location-object (2df x) (2df y) (2df z) (2df h)))
    

    (defstruct (location-rgba 
                (:print-function print-location)
                (:include location-3)
                (:conc-name %location-rgba-)
                (:constructor %location-rgba (x y z h)))
      "a location ndc is a location-3 which constrains x,y,z,h to the short-float domain")
    (defun location-rgba (&optional (r 0.0s0) (g 0.0s0) (b 0.0s0) (a 1.0s0))
      (%location-rgba (2sf r) (2sf g) (2sf b) (2sf a)))
    (defun make-location-rgba (&key (r 0.0s0) (g 0.0s0) (b 0.0s0) (a 1.0s0))
      (%location-rgba (2sf r) (2sf g) (2sf b) (2sf a)))
    (defun rgba (r g b &optional (a 1.0s0)) (location-rgba r g b a))
    
    ;;;; subtypes for spherical spaces
    (defstruct (location-polar
                (:print-function print-location)
                (:conc-name %location-polar-)
                (:constructor location-polar (&optional alpha radius)))
      (alpha 0.0d0) (radius 0.0d0))
    (defun make-location-polar (&key (alpha 0.0d0) (radius 0.0d0))
      (location-polar alpha radius))

    (defstruct (location-spherical
                (:print-function print-location)
                (:include location-polar)
                (:conc-name %location-spherical-)
                (:constructor %location-spherical (&optional alpha beta radius)))
      (beta 0.0d0))
    (defun make-location-spherical (&key (alpha 0.0d0) (beta 0.0d0) (radius 0.0d0))
      (%location-spherical alpha beta radius))
    (defun location-spherical (&optional (alpha 0.0d0) (beta 0.0d0) (radius 0.0d0))
      (%location-spherical (2df alpha) (2df beta) (2df radius)))

    (defun location-alpha (location) (%location-polar-alpha location))
    (defun (setf location-alpha) (value location) (setf (%location-polar-alpha location) value))
    (defun location-beta (location) (%location-spherical-beta location))
    (defun (setf location-beta) (value location) (setf (%location-spherical-beta location) value))
    (defun location-radius (location) (%location-polar-radius location))
    (defun (setf location-radius) (value location) (setf (%location-polar-radius location) value))
    
    (defvar *location-vector-type*
      (type-of (make-array 4 :initial-element 0.0d0 :element-type 'double-float)))
    (defvar *location-vector-element-type*
      (array-element-type (make-array 4 :initial-element 0.0d0 :element-type 'double-float)))
    (defvar *short-location-vector-type*
      (type-of (make-array 4 :initial-element 0.0s0 :element-type 'single-float)))
    (defvar *short-location-vector-element-type*
      (array-element-type (make-array 4 :initial-element 0.0s0 :element-type 'single-float)))
    (defvar *fixnum-location-vector-element-type* 'fixnum)
    (defvar *fixnum-location-vector-type*
      (type-of (make-array 4 :initial-element 0 :element-type 'fixnum)))
    (deftype location-vector ()
      "a (4) double float simple array intended to hold location coordinates."
      *location-vector-type*)
    (deftype short-location-vector ()
      "a (4) short float simple array intended to hold location coordinates."
      *short-location-vector-type*)
    (deftype fixnum-location-vector ()
      "a (4) fixnum simple array intended to hold location coordinates."
      *fixnum-location-vector-type*)
    
    (defun location-vector-p (x)
      (and (typep x 'simple-array)
           (eq (array-element-type x) *location-vector-element-type*)
           (= (array-rank x) 1)
           (= (length x) 4)))
    (defun short-location-vector-p (x)
      (and (typep x 'simple-array)
           (eq (array-element-type x) *short-location-vector-element-type*)
           (= (array-rank x) 1)
           (= (length x) 4)))
    (defun fixnum-location-vector-p (x)
      (and (typep x 'simple-array)
           (eq (array-element-type x) *fixnum-location-vector-element-type*)
           (= (array-rank x) 1)
           (= (length x) 4)))
    
    )) ;end eval-when

;;;
;;; vectors

(defun location-vector (&rest initial-values)
  (declare (dynamic-extent initial-values))
  (let ((result (make-array 4  :element-type 'double-float :initial-element 0.0d0)))
    (when initial-values (copy2double-location-vector initial-values result))
    result))

(defun short-location-vector ()
  (make-array 4  :element-type 'single-float :initial-element 0.0s0))

(defun fixnum-location-vector ()
  (make-array 4  :element-type 'fixnum :initial-element 0))

(defmethod location-x ((location vector)) (the double-float (aref location 0)))
(defmethod location-y ((location vector)) (the double-float (aref location 1)))
(defmethod location-z ((location vector)) (if (> (length location) 2) (the double-float (aref location 2)) 0.0d0))
(defmethod location-h ((location vector)) (if (> (length location) 3) (the double-float (aref location 3)) 0.0d0))
(defmethod (setf location-x) ((value #-clisp double-float #+clisp t) (location vector)) (setf (aref location 0) value))
(defmethod (setf location-y) ((value #-clisp double-float #+clisp t) (location vector)) (setf (aref location 1) value))
(defmethod (setf location-z) ((value #-clisp double-float #+clisp t) (location vector)) (setf (aref location 2) value))
(defmethod (setf location-h) ((value #-clisp double-float #+clisp t) (location vector)) (setf (aref location 3) value))


(document (copy2double-location-vector copy2short-location-vector copy2fixnum-location-vector)
  "These are the _internal_, _unsafe_ operators to copy location vectors.
 The interfaces operator `copy-location-vector` dispatches by argument/result type to the
 correct implementation.")


(defun copy2double-location-vector (v result)
  (declare (optimize (speed 3) (safety 0))
           (type location-vector result))
  (etypecase v
    (location-vector
     (locally (declare (type location-vector v))
       (setf (aref result 0) (aref v 0))
       (setf (aref result 1) (aref v 1))
       (setf (aref result 2) (aref v 2))
       (setf (aref result 3) (aref v 3))))
    (short-location-vector
     (locally (declare (type short-location-vector v))
       (setf (aref result 0) (* 1.0d0 (aref v 0)))
       (setf (aref result 1) (* 1.0d0 (aref v 1)))
       (setf (aref result 2) (* 1.0d0 (aref v 2)))
       (setf (aref result 3) (* 1.0d0 (aref v 3)))))
    (fixnum-location-vector
     (locally (declare (type fixnum-location-vector v))
       (setf (aref result 0) (* 1.0d0 (aref v 0)))
       (setf (aref result 1) (* 1.0d0 (aref v 1)))
       (setf (aref result 2) (* 1.0d0 (aref v 2)))
       (setf (aref result 3) (* 1.0d0 (aref v 3)))))
    ((or location-world location-object)
     (locally (declare (ftype (function (location-3) double-float)
                              %location-x %location-y %location-z %location-h))
       (setf (aref result 0) (%location-x v)
             (aref result 1) (%location-y v)
             (aref result 2) (%location-z v)
             (aref result 3) (%location-h v))))
    (location-ndc
     (locally (declare (ftype (function (location-3) single-float)
                              %location-ndc-x %location-ndc-y %location-ndc-z %location-ndc-h))
       (setf (aref result 0) (* 1.0d0 (%location-ndc-x v))
             (aref result 1) (* 1.0d0 (%location-ndc-y v))
             (aref result 2) (* 1.0d0 (%location-ndc-z v))
             (aref result 3) (* 1.0d0 (%location-ndc-h v)))))
    (location-port
     (locally (declare (ftype (function (location-3) integer)
                              %location-port-x %location-port-y %location-port-z %location-port-h))
       (setf (aref result 0) (* 1.0d0 (%location-port-x v))
             (aref result 1) (* 1.0d0 (%location-port-y v))
             (aref result 2) (* 1.0d0 (%location-port-z v))
             (aref result 3) (* 1.0d0 (%location-port-h v)))))
    (location-2
     (locally (declare (type location-2 v))
       (setf (aref result 0) (float (%location-2-x v) 1.0d0)
             (aref result 1) (float (%location-2-y v) 1.0d0)
             (aref result 2) (float (location-z v) 1.0d0)
             (aref result 3) (float (location-h v) 1.0d0))))
    (fixnum
     (locally (declare (type fixnum v)))
     (setf (aref result 0) (float (point-h v) 1.0d0)
           (aref result 1) (float (point-v v) 1.0d0)
           (aref result 2) 0.0d0
           (aref result 3) 1.0d0))
    (cons
     (unless (numberp (first v)) (pop v))
     (setf (aref result 0) (float (or (pop v) 0.0) 1.0d0)
           (aref result 1) (float (or (pop v) 0.0) 1.0d0)
           (aref result 2) (float (or (pop v) 0.0) 1.0d0)
           (aref result 3) (float (or (pop v) 0.0) 1.0d0)))
    (null
     (setf (aref result 0) 0.0d0
           (aref result 1) 0.0d0
           (aref result 2) 0.0d0
           (aref result 3) 1.0d0)))
  result)


(defun copy2short-location-vector (v result)
  (declare (optimize (speed 3) (safety 0))
           (type short-location-vector result))
  (etypecase v
    (location-vector
     (locally (declare (type location-vector v))
       (setf (aref result 0) (float (aref v 0) 1.0s0))
       (setf (aref result 1) (float (aref v 1) 1.0s0))
       (setf (aref result 2) (float (aref v 2) 1.0s0))
       (setf (aref result 3) (float (aref v 3) 1.0s0))))
    (short-location-vector
     (locally (declare (type short-location-vector v))
       (setf (aref result 0) (aref v 0))
       (setf (aref result 1) (aref v 1))
       (setf (aref result 2) (aref v 2))
       (setf (aref result 3) (aref v 3))))
    (fixnum-location-vector
     (locally (declare (type fixnum-location-vector v))
       (setf (aref result 0) (float (aref v 0) 1.0s0))
       (setf (aref result 1) (float (aref v 1) 1.0s0))
       (setf (aref result 2) (float (aref v 2) 1.0s0))
       (setf (aref result 3) (float (aref v 3) 1.0s0))))
    ((or location-world location-object)
     (locally (declare (ftype (function (location-3) double-float)
                              %location-x %location-y %location-z %location-h))
       (setf (aref result 0) (float (%location-x v) 1.0s0)
             (aref result 1) (float (%location-y v) 1.0s0)
             (aref result 2) (float (%location-z v) 1.0s0)
             (aref result 3) (float (%location-h v) 1.0s0))))
    (location-ndc
     (locally (declare (ftype (function (location-3) single-float)
                              %location-ndc-x %location-ndc-y %location-ndc-z %location-ndc-h))
       (setf (aref result 0) (%location-ndc-x v)
             (aref result 1) (%location-ndc-y v)
             (aref result 2) (%location-ndc-z v)
             (aref result 3) (%location-ndc-h v))))
    (location-port
     (locally (declare (ftype (function (location-3) integer)
                              %location-port-x %location-port-y %location-port-z %location-port-h))
       (setf (aref result 0) (float (%location-port-x v) 1.0s0)
             (aref result 1) (float (%location-port-y v) 1.0s0)
             (aref result 2) (float (%location-port-z v) 1.0s0)
             (aref result 3) (float (%location-port-h v) 1.0s0))))
    (location-2
     (locally (declare (type location-2 v))
       (setf (aref result 0) (float (%location-x v) 1.0s0)
             (aref result 1) (float (%location-y v) 1.0s0)
             (aref result 2) 0.0s0
             (aref result 3) 1.0s0)))
    (fixnum
     (locally (declare (type fixnum v)))
     (setf (aref result 0) (float (point-h v) 1.0s0)
           (aref result 1) (float (point-v v) 1.0s0)
           (aref result 2) 0.0s0
           (aref result 3) 1.0s0))
    (cons
     (unless (numberp (first v)) (pop v))
     (setf (aref result 0) (float (location-x v) 1.0s0)
           (aref result 1) (float (location-y v) 1.0s0)
           (aref result 2) (float (location-z v) 1.0s0)
           (aref result 3) (float (location-h v) 1.0s0)))
    (null
     (setf (aref result 0) 0.0s0
           (aref result 1) 0.0s0
           (aref result 2) 0.0s0
           (aref result 3) 1.0s0)))
  result)


(defun copy2fixnum-location-vector (v result)
  (declare (optimize (speed 3) (safety 0))
           (type fixnum-location-vector result))
  (cond ((location-vector-p v)
         (locally (declare (type location-vector v))
          ;; (setf (aref result 0) (%round (aref v 0)))
          ; (setf (aref result 1) (%round (aref v 1)))
          ; (setf (aref result 2) (%round (aref v 2)))
           (setf (aref result 3) (%round (aref v 3)))))
        ((short-location-vector-p v)
         (locally (declare (type short-location-vector v))
          ; (setf (aref result 0) (round (aref v 0)))
          ; (setf (aref result 1) (round (aref v 1)))
          ; (setf (aref result 2) (round (aref v 2)))
           (setf (aref result 3) (round (aref v 3)))))
        (t (typecase v
             (vector
              (locally (declare (type vector v))
                (dotimes (i 4) (setf (aref result i) (round (aref v i))))))
             (location-2
              (locally (declare (type location-2 v))
                (setf (aref result 0) (round (%location-x v))
                      (aref result 1) (round (%location-y v))
                      (aref result 2) (round (location-z v))
                      (aref result 3) (round (location-h v)))))
             (fixnum
              (locally (declare (type fixnum v)))
              (setf (aref result 0) (point-h v)
                    (aref result 1) (point-v v)
                    (aref result 2) 0
                    (aref result 3) 1))
             (cons
              (setf (aref result 0) (round (location-x v))
                    (aref result 1) (round (location-y v))
                    (aref result 2) (round (location-z v))
                    (aref result 3) (round (location-h v))))
             (null
              (setf (aref result 0) 0
                    (aref result 1) 0
                    (aref result 2) 0
                    (aref result 3) 1))
             (t
              (error "can't copy: ~s ~s." v result)))))
  result)

(defun location-vector-copy (v &optional (result (location-vector)))
  "the rules for efficiency appear to be:
   - no direct cross-type assignment
   - cross-type operands cons indepedent of result type
   - homogeneous operands assign to any type without consing
   - explicit coerces or floats cons"
  (declare (optimize (speed 3) (safety 0)))
  (etypecase result
    (location-vector
     (copy2double-location-vector v result))
    (short-location-vector
     (copy2short-location-vector v result))
    (fixnum-location-vector result)
    (copy2fixnum-location-vector v result)))

;(let ((s (short-location-vector)) (l (location-vector))) (time (location-vector-copy s l)) (time (location-vector-copy l s)))


(defun double-location-vector-copy (v &optional (result (location-vector) result-s))
  (when result-s
    (assert-type result location-vector))
  (copy2double-location-vector v result))

(defun short-location-vector-copy (v &optional (result (short-location-vector) result-s))
  (when result-s
    (assert-type result short-location-vector))
  (copy2short-location-vector v result))

(defun fixnum-location-vector-copy (v &optional (result (fixnum-location-vector) result-s))
  (when result-s
    (assert-type result fixnum-location-vector))
  (copy2fixnum-location-vector v result))


(declaim (ftype (function (t &optional t) vector) location-vector-copy)
         (ftype (function (t &optional t) location-vector) double-location-vector-copy)
         (ftype (function (t &optional t) short-location-vector) short-location-vector-copy)
         (ftype (function (t &optional t) fixnum-location-vector) fixnum-location-vector-copy)
         (ftype (function (t location-vector) location-vector) copy2double-location-vector)
         (ftype (function (t short-location-vector) short-location-vector) copy2short-location-vector)
         (ftype (function (t fixnum-location-vector) fixnum-location-vector) copy2fixnum-location-vector))


(defParameter *double-locations* (make-array 0 :fill-pointer 0 :adjustable t)
  "holds location-vector instances")

(defParameter *short-locations* (make-array 0 :fill-pointer 0 :adjustable t)
  "holds short-location-vector instances")

(defParameter *fixnum-locations* (make-array 0 :fill-pointer 0 :adjustable t)
  "holds fixnum-location-vector instances")


(defun get-location-vector ()
  (declare (optimize (speed 3) (safety 0)))
  (if (and *double-locations* (> (fill-pointer *double-locations*) 0))
    (vector-pop *double-locations*)
    (location-vector)))

(defun get-short-location-vector ()
  (if (and *short-locations* (> (fill-pointer *short-locations*) 0))
    (vector-pop *short-locations*)
    (short-location-vector)))

(defun get-fixnum-location-vector ()
  (if (and *fixnum-locations* (> (fill-pointer *fixnum-locations*) 0))
    (vector-pop *fixnum-locations*)
    (fixnum-location-vector)))

(defun return-location-vector (location)
  (when *double-locations*
    (vector-push-extend location *double-locations*)))

(defun return-short-location-vector (location)
  (when *short-locations*
    (vector-push-extend location *short-locations*)))

(defun return-fixnum-location-vector (location)
  (when *fixnum-locations*
    (vector-push-extend location *fixnum-locations*)))


;;;; --------------------------------------------------------------------------
;;;; point definitions for non-digitool lisps

#-:digitool
(progn
  (defun point-h (p) (logand p #x3fff))
  (defun point-v (p) (logand (ash p -14) #x3fff))
  (defun make-point (h &optional v)
    (if v (logior (ash v 14) (logand #x3fff h)) (logand #x3fff h)))
  (defun add-points (p1 p2)
    (make-point (+ (point-h p1) (point-h p2)) (+ (point-v p1) (point-v p2))))
  (defun subtract-points (p1 p2)
    (make-point (- (point-h p1) (point-h p2)) (- (point-v p1) (point-v p2))))
  (defun point-string (point)
    (format nil "#@(~d ~d)" (point-h point) (point-v point)))
  )

;;;; --------------------------------------------------------------------------
;;;; generic accessors

(defmacro with-coerced-variables ((&rest specs) &rest body)
  "coerce the variables to specified types and declare it within the body."
  (flet ((spec-declaration (spec) (cons 'type spec))
         (spec-bindings (spec)
           (destructuring-bind (type . variables) spec
             (mapcar #'(lambda (variable)
                         `(,variable
                           ,(case type
                              (integer `(if (typep ,variable 'integer) ,variable (round ,variable)))
                              (fixnum `(if (typep ,variable 'fixnum) ,variable (setf ,variable (round ,variable))))
                              (single-float `(if (typep ,variable 'single-float) ,variable (setf ,variable (float ,variable 1.0s0))))
                              (double-float `(if (typep ,variable 'double-float) ,variable (setf ,variable (* ,variable 1.0d0))))
                              (location-vector `(if (location-vector-p ,variable) ,variable (location-vector-copy ,variable (location-vector))))
                              (short-location-vector `(if (short-location-vector-p ,variable) ,variable (location-vector-copy ,variable (short-location-vector))))
                              (fixnum-location-vector `(if (fixnum-location-vector-p ,variable) ,variable (location-vector-copy ,variable (fixnum-location-vector)))))))
                     variables))))
    `(let ,(reduce #'append (mapcar #'spec-bindings specs))
       (declare ,@(mapcar #'spec-declaration specs))
       ,@body)))


(defGeneric location-x (l)
  (:documentation
   "access the location x-coordinate. permits fixnum, structure, list, vector, and simple-vector locations.")
  (:method ((l fixnum)) (point-h l))
  (:method ((l location-2)) (%location-x l))
  (:method ((l cons)) (car l))
  (:method ((l vector)) (aref l 0)))

(defGeneric location-y (l)
  (:method ((l fixnum)) (point-v l))
  (:method ((l location-2)) (%location-y l))
  (:method ((l cons)) (cadr l))
  (:method ((l vector)) (aref l 1)))

(defGeneric location-z (c)
  (:method ((l fixnum)) 0.0d0)
  (:method ((l location-2)) 0.0d0)
  (:method ((l location-3)) (%location-z l))
  (:method ((l cons)) (or (caddr l) 0.0d0))
  (:method ((l vector)) (if (> (length l) 2) (aref l 2) 0.0d0)))

(defGeneric location-h (c)
  (:method ((l fixnum)) 0.0d0)
  (:method ((l location-2)) 0.0d0)
  (:method ((l location-3)) 0.0d0)
  (:method ((l location-4)) (%location-h l))
  (:method ((l cons)) (or (cadddr l) 1.0d0))
  (:method ((l vector)) (if (> (length l) 3) (aref l 3) 1.0d0)))

(defGeneric location-time (c)
  (:method ((l fixnum)) 0.0d0)
  (:method ((l location-2)) 0.0d0)
  (:method ((l cons)) (or (fifth l) 0.0d0))
  (:method ((l vector)) (if (> (length l) 4) (aref l 4) 0.0d0))
  (:method ((l location-4)) (%location-4-time l)))

(defGeneric (setf location-x) (value l)
  (:method ((v number) (l fixnum)) (make-point (point-h (typecase v (integer v) (t (round v)))) (point-v l)))
  (:method ((v number) (l cons)) (setf (first l) v))
  (:method ((v number) (l location-2)) (setf (%location-2-x l) v))
  (:method ((v integer) (l location-port))        (setf (%location-port-x l) v))
  (:method ((v real) (l location-port))           (setf (%location-port-x l) (round v)))
  (:method ((v real) (l location-ndc))            (setf (%location-ndc-x l) (float v 1.0s0)))
  (:method ((v single-float) (l location-ndc))     (setf (%location-ndc-x l) v))
  (:method ((v real) (l location-world))          (setf (%location-world-x l) (float v 1.0d0)))
  (:method ((v double-float) (l location-world))  (setf (%location-world-x l) v))
  (:method ((v real) (l location-object))         (setf (%location-object-x l) (float v 1.0d0)))
  (:method ((v double-float) (l location-object)) (setf (%location-object-x l) v))
  (:method ((v number) (l vector))
           (declare (optimize (speed 3) (safety 0)))
           (when (>= (length l) 1)
             (etypecase l
               (location-vector
                (locally (declare (type location-vector l))
                  (setf (aref l 0) (etypecase v (double-float v) (real (* 1.0d0 v))))))
               (short-location-vector
                (locally (declare (type short-location-vector l))
                  (setf (aref l 0) (etypecase v (single-float v) (real (* 1.0s0 v))))))
               (fixnum-location-vector
                (locally (declare (type fixnum-location-vector l))
                  (setf (aref l 0) (etypecase v (fixnum v) (real (round v))))))))))

(defGeneric (setf location-y) (value l)
  (:method ((v number) (l fixnum))                (make-point (point-h l) (point-v (typecase v (integer v) (t (round v))))))
  (:method ((v number) (l cons))                  (when (setf l (cdr l)) (setf (first l) v)))
  (:method ((v number) (l location-2))            (setf (%location-2-y l) v))
  (:method ((v integer) (l location-port))        (setf (%location-port-y l) v))
  (:method ((v real) (l location-port))           (setf (%location-port-y l) (round v)))
  (:method ((v real) (l location-ndc))            (setf (%location-ndc-y l) (float v 1.0s0)))
  (:method ((v single-float) (l location-ndc))     (setf (%location-ndc-y l) v))
  (:method ((v real) (l location-world))          (setf (%location-world-y l) (float v 1.0d0)))
  (:method ((v double-float) (l location-world))  (setf (%location-world-y l) v))
  (:method ((v real) (l location-object))         (setf (%location-object-y l) (float v 1.0d0)))
  (:method ((v double-float) (l location-object)) (setf (%location-object-y l) v))
  (:method ((v number) (l vector))
           (declare (optimize (speed 3) (safety 0)))
           (when (>= (length l) 2)
             (etypecase l
               (location-vector
                (locally (declare (type location-vector l))
                  (setf (aref l 1) (etypecase v (double-float v) (real (* 1.0d0 v))))))
               (short-location-vector
                (locally (declare (type short-location-vector l))
                  (setf (aref l 1) (etypecase v (single-float v) (real (* 1.0s0 v))))))
               (fixnum-location-vector
                (locally (declare (type fixnum-location-vector l))
                  (setf (aref l 1) (etypecase v (fixnum v) (real (round v))))))))))

(defGeneric (setf location-z) (value l)
  (:method ((v number) (l cons)) (when (setf l (cddr l)) (setf (first l) v)))
  (:method ((v real) (l location-2))              v)    ; ignore it
  (:method ((v integer) (l location-port))        (setf (%location-port-z l) v))
  (:method ((v real) (l location-port))           (setf (%location-port-z l) (round v)))
  (:method ((v real) (l location-ndc))            (setf (%location-ndc-z l) (float v 1.0s0)))
  (:method ((v single-float) (l location-ndc))     (setf (%location-ndc-z l) v))
  (:method ((v real) (l location-world))          (setf (%location-world-z l) (float v 1.0d0)))
  (:method ((v double-float) (l location-world))  (setf (%location-world-z l) v))
  (:method ((v real) (l location-object))         (setf (%location-object-z l) (float v 1.0d0)))
  (:method ((v double-float) (l location-object)) (setf (%location-object-z l) v))
  (:method ((v number) (l vector))
           (declare (optimize (speed 3) (safety 0)))
           (when (>= (length l) 3)
             (etypecase l
               (location-vector
                (locally (declare (type location-vector l))
                  (setf (aref l 2) (etypecase v (double-float v) (real (* 1.0d0 v))))))
               (short-location-vector
                (locally (declare (type short-location-vector l))
                  (setf (aref l 2) (etypecase v (single-float v) (real (* 1.0s0 v))))))
               (fixnum-location-vector
                (locally (declare (type fixnum-location-vector l))
                  (setf (aref l 2) (etypecase v (fixnum v) (real (round v))))))))))

(defGeneric (setf location-h) (value l)
  (:method ((v real) (l cons))                    (when (setf l (cdddr l)) (setf (first l) v)))
  (:method ((v real) (l location-2))              v)    ; ignore it
  (:method ((v integer) (l location-port))        (setf (%location-port-h l) v))
  (:method ((v real) (l location-port))           (setf (%location-port-h l) (round v)))
  (:method ((v real) (l location-ndc))            (setf (%location-ndc-h l) (float v 1.0s0)))
  (:method ((v single-float) (l location-ndc))     (setf (%location-ndc-h l) v))
  (:method ((v real) (l location-world))          (setf (%location-world-h l) (float v 1.0d0)))
  (:method ((v double-float) (l location-world))  (setf (%location-world-h l) v))
  (:method ((v real) (l location-object))         (setf (%location-object-h l) (float v 1.0d0)))
  (:method ((v double-float) (l location-object)) (setf (%location-object-h l) v))
  (:method ((v number) (l vector))
           (declare (optimize (speed 3) (safety 0)))
           (when (>= (length l) 4)
             (etypecase l
               (location-vector
                (locally (declare (type location-vector l))
                  (setf (aref l 3) (etypecase v (double-float v) (real (* 1.0d0 v))))))
               (short-location-vector
                (locally (declare (type short-location-vector l))
                  (setf (aref l 3) (etypecase v (single-float v) (real (* 1.0s0 v))))))
               (fixnum-location-vector
                (locally (declare (type fixnum-location-vector l))
                  (setf (aref l 3) (etypecase v (fixnum v) (real (round v))))))))))


(defGeneric (setf location-time) (value l)
  (:method ((v real) (l cons)) (when (setf l (cddddr l)) (setf (first l) v)))
  (:method ((v double-float) (l location-4)) (setf (%location-4-time l) v))
  (:method ((v real) (l location-4)) (setf (%location-4-time l) (float v 1.0d0)))
  (:method ((v real) (l vector))
           (declare (optimize (speed 3) (safety 0)))
           (when (>= (length l) 5)
             (etypecase l
               (location-vector
                (locally (declare (type location-vector l))
                  (setf (aref l 4) (etypecase v (double-float v) (real (* 1.0d0 v))))))
               (short-location-vector
                (locally (declare (type short-location-vector l))
                  (setf (aref l 4) (etypecase v (single-float v) (real (* 1.0s0 v))))))
               (fixnum-location-vector
                (locally (declare (type fixnum-location-vector l))
                  (setf (aref l 4) (etypecase v (fixnum v) (real (round v))))))))))

(defGeneric rgba-r (color)
  (:method ((color location-rgba)) (%location-x color)))

(defGeneric rgba-g (color)
  (:method ((color location-rgba)) (%location-y color)))

(defGeneric rgba-b (color)
  (:method ((color location-rgba)) (%location-z color)))

(defGeneric rgba-a (color)
  (:method ((color location-rgba)) (%location-h color)))

(defGeneric (setf rgba-r) (value color)
  (:method ((v number) (color location-rgba))
           (setf (%location-x color) (typecase v (single-float v) (t (float v 1.0s0))))))

(defGeneric (setf rgba-g) (value color)
  (:method ((v number) (color location-rgba))
           (setf (%location-y color) (typecase v (single-float v) (t (float v 1.0s0))))))

(defGeneric (setf rgba-b) (value color)
  (:method ((v number) (color location-rgba))
           (setf (%location-z color) (typecase v (single-float v) (t (float v 1.0s0))))))

(defGeneric (setf rgba-a) (value color)
  (:method ((v number) (color location-rgba))
           (setf (%location-h color) (typecase v (single-float v) (t (float v 1.0s0))))))



;;;;
;;; constructors


(defmacro _location-vector-set (vector &optional v0 v1 v2 v3)
  "generate (setf (aref i ) v_i) for the four values and the coordiante vector."
  `(progn (setf (aref ,vector 0) ,v0
                (aref ,vector 1) ,v1
                (aref ,vector 2) ,v2
                (aref ,vector 3) ,v3)
          ,vector))

(defun location-vector-set (vector x y z &optional (h 1.0d0))
  (declare (type double-float x y z h)
           (type location-vector vector)
           (optimize (speed 3) (safety 0)))
  (assert-type vector location-vector)
  (_location-vector-set vector x y z h)
  vector)

(defMacro with-location-vectors (bindings &rest body)
  "establish dynamic bindings to resourced location-vectors and initialize them according to value specifications
   of the form expected by location-vector-set.
   use * rather than calling float to allow it to be coded inline."
  `(let ,(mapcar #'(lambda (binding &aux (name (if (listp binding) (first binding) binding)))
                     `(,name (get-location-vector)))
                 bindings)
     (declare (type location-vector ,@(mapcar #'(lambda (binding) (if (listp binding) (first binding) binding))
                                     bindings)))
     ,@(remove nil (mapcar #'(lambda (binding)
                               (when (listp binding)
                                 (destructuring-bind (&optional x y z h) (rest binding)
                                   `(_location-vector-set ,(first binding)
                                                          ,(if x `(* ,x 1.0d0) 0.0d0)
                                                          ,(if y `(* ,y 1.0d0) 0.0d0)
                                                          ,(if z `(* ,z 1.0d0) 0.0d0)
                                                          ,(if h `(* ,h 1.0d0) 1.0d0)))))
                           bindings))
     (unwind-protect (progn ,@body)
       ,@(mapcar #'(lambda (binding) `(return-location-vector ,(if (listp binding) (first binding) binding)))
                 bindings))))

(defMacro with-short-location-vectors (bindings &rest body)
  "establish dynamic bindings to resourced short-location-vectors and initialize them according to value specifications
   of the form expected by location-vector-set."
  `(let ,(mapcar #'(lambda (binding &aux (name (if (listp binding) (first binding) binding)))
                     `(,name (get-short-location-vector)))
                 bindings)
     (declare (type short-location-vector ,@(mapcar #'(lambda (binding) (if (listp binding) (first binding) binding))
                                     bindings)))
     ,@(remove nil (mapcar #'(lambda (binding)
                               (when (listp binding)
                                 (destructuring-bind (&optional x y z h) (rest binding)
                                   `(_location-vector-set ,(first binding)
                                                          ,(if x `(* ,x 1.0s0) 0.0s0)
                                                          ,(if y `(* ,y 1.0s0) 0.0s0)
                                                          ,(if z `(* ,z 1.0s0) 0.0s0)
                                                          ,(if h `(* ,h 1.0s0) 1.0s0)))))
                           bindings))
     (unwind-protect (progn ,@body)
       ,@(mapcar #'(lambda (binding) `(return-short-location-vector ,(if (listp binding) (first binding) binding)))
                 bindings))))


(defun make-location-vector (&key (x 0.0d0) (y 0.0d0) (z 0.0d0) (h 1.0d0))
  (let ((v (location-vector)))
    (declare (type location-vector v))
    (setf (aref v 0) (float x 1.0d0)
          (aref v 1) (float y 1.0d0)
          (aref v 2) (float z 1.0d0)
          (aref v 3) (float h 1.0d0))
    v))

(defun make-short-location-vector (&key (x 0.0s0) (y 0.0s0) (z 0.0s0) (h 1.0s0))
  (let ((v (short-location-vector)))
    (declare (type short-location-vector v))
    (setf (aref v 0) (float x 1.0s0)
          (aref v 1) (float y 1.0s0)
          (aref v 2) (float z 1.0s0)
          (aref v 3) (float h 1.0s0))
    v))

(defun make-fixnum-location-vector (&key (x 0) (y 0) (z 0) (h 1))
  (let ((v (fixnum-location-vector)))
    (declare (type fixnum-location-vector v))
    (with-coerced-variables ((fixnum x y z h))
      (setf (aref v 0) x
            (aref v 1) y
            (aref v 2) z
            (aref v 3) h)
      v)))


;;;
;;; spread location coordinates generically

(defGeneric call-with-location*3 (function location)
  (:argument-precedence-order location function)
  (:method ((function t) (location fixnum))
           (funcall function (point-h location) (point-v location) 0))
  (:method ((function t) (location list))
           (destructuring-bind (&optional (x 0.0) (y 0.0) (z 0.0))
                               (if (numberp (first location)) location (rest location))
             (funcall function x y z)))
  (:method ((function t) (location vector))
           (funcall function (aref location 0) (aref location 1)
                    (if (> (length location) 2) (aref location 2) 0.0)))
  (:method ((function t) (location location-2))
           (funcall function (location-x location) (location-y location)
                    (location-z location))))

(defGeneric call-with-location*4 (function location)
  (:argument-precedence-order location function)
  (:method ((function t) (location fixnum))
           (funcall function (point-h location) (point-v location) 0 0))
  (:method ((function t) (location list))
           (destructuring-bind (&optional (x 0.0) (y 0.0) (z 0.0) (h 0.0))
                               (if (numberp (first location)) location (rest location))
             (funcall function x y z h)))
  (:method ((function t) (location vector))
           (funcall function (aref location 0) (aref location 1)
                    (if (> (length location) 2) (aref location 2) 0.0)
                    (if (> (length location) 3) (aref location 3) 0.0)))
  (:method ((function t) (location location-2))
           (funcall function (location-x location) (location-y location)
                    (location-z location) (location-h location))))
  

(defMacro with-location-coordinates (coordinate-bindings &rest body)
  "execute the body in the context of the specified coordinate bindings.
   <br ><code>(with-location-coordinates <i>bindings</i> . <i>body<.I>)</code><br />
each binding take the form <code>((<i>x</i> <i>y</i> &optional <i>z</i>) <i>location</i>),
where the location may be a single expression which evaluates to a location instance,
or it may be a sequence of expressions which evaluate to coordinates. within the body,
the <code><i>x</i></code>, <code><i>y</i></code>, and optionally <code><i>z</i></code>
variables are bound to respective coordiante values."
  (if (null coordinate-bindings)
    `(progn ,@body)
    (destructuring-bind (coordinate-binding . rest-bindings) coordinate-bindings
      (let ((spread-coordinates nil)
            (bind-coordinates (gensym "BIND-COORDINATES-")))
        (destructuring-bind ((sx sy &rest z-h-and-keys) location &aux sz sh) coordinate-binding
          (typecase (first z-h-and-keys)
            ((or keyword null) nil)
            (t (setf sz (pop z-h-and-keys))))
          (typecase (first z-h-and-keys)
            ((or keyword null) nil)
            (t (setf sh (pop z-h-and-keys))))
          (setf spread-coordinates
                (list* sx sy (when sz (list* sz (when sh (list sh))))))
          (destructuring-bind (&key (function (cond (sh 'call-with-location*4)
                                                    (sz 'call-with-location*3)
                                                    (t 'call-with-location*2))))
                              z-h-and-keys
            `(flet ((,bind-coordinates ,spread-coordinates
                      (declare (ignorable ,sz))
                      (with-location-coordinates ,rest-bindings ,@body)))
               (declare (dynamic-extent #',bind-coordinates))
               (,function #',bind-coordinates ,location))))))))

;;(time (with-location-coordinates (((x1 y1 z1) #@(|3| 1 2 3)) ((x2 y2 l2) #@(|3| 4 5 6))) (= x1 y1 z1 x2 y2 l2)))

;;; --------------------------------------------------------------------------
;;; print and read functions

  

(defGeneric location-class-nickname (location)
  (:documentation
   "returns a class nickname for printing")
  (:method ((c null)) nil)
  (:method ((c location-object)) '|object|)
  (:method ((c location-world)) '|world|)
  (:method ((c location-ndc)) '|ndc|)
  (:method ((c location-port)) '|port|)
  (:method ((c location-rgba)) '|rgba|)
  (:method ((c location-4)) '|4|)
  (:method ((c location-3)) '|3|)
  (:method ((c location-2)) '|2|)
  (:method ((c location-spherical)) '|spherical|)
  (:method ((c location-polar)) '|polar|)
  (:method ((c number)) '||))
  
(defun print-location (c &optional (stream *standard-output*)
                           (print-level *print-level*)
                           &aux (abbreviate nil))
  (declare (ignore print-level))
  (write-string "#@(" stream)
  (let ((*package* *location-package*)
        (nickname (location-class-nickname c)))
    (case nickname
      ((|2| |3| |4|) (cond ((eql (location-h c) 1) (setf abbreviate t))
                           (t (write nickname :stream stream) (write-char #\space stream))))
      (t (princ nickname stream) (write-char #\space stream))))

  (typecase c
    (location-2
     (write (location-x c) :stream stream :pretty nil)
     (write-char #\space stream)
     (write (location-y c) :stream stream :pretty nil)
     (when (location-3-p c)
       (write-char #\space stream)
       (write (location-z c) :stream stream :pretty nil)
       (when (location-4-p c)
         (write-char #\space stream)
         (write (location-time c) :stream stream :pretty nil)))
     (unless abbreviate
       (write-char #\space stream)
       (write (location-h c) :stream stream :pretty nil)))
    (location-polar
     (write (%location-polar-alpha c) :stream stream :pretty nil)
     (write-char #\space stream)
     (when (location-spherical-p c)
       (write (%location-spherical-beta c) :stream stream :pretty nil)
       (write-char #\space stream))
     (write (%location-polar-radius c) :stream stream :pretty nil))
    (number
     (let ((c-floor (floor c)))
       (format stream "~d ~d" (point-h c-floor) (point-v c-floor)))))
  (write-char #\) stream)
  c)

(defgeneric cl-user::format-location (stream datum &key)
  (:method ((stream stream) (datum t) &key &allow-other-keys)
           (print-location datum stream))
  (:method ((datum t) (stream stream) &key &allow-other-keys)
           (print-location datum stream)))

(defgeneric location-list (location)
  (:method ((location integer))
           (list (point-h location) (point-v location)))
  (:method ((location vector))
           (map 'list #'identity location))
  (:method ((location location-2))
           (list (location-x location)
                 (location-y location)
                 (location-z location)
                 (location-h location))))

(defun location-namestring (c)
  (cond ((location-2-p c)
         (format nil "(~$ ~$~:[~; ~$~:[~; ~$~]~])"
                 (location-x c)
                 (location-y c)
                 (location-3-p c)
                 (if (location-3-p c) (location-z c))
                 (location-4-p c)
                 (if (location-4-p c) (location-time c))))
        ((location-polar-p c)
         (format nil "(~$ ~$~:[~; ~$~])"
                 (%location-polar-alpha c)
                 (if (location-spherical-p c)
                   (%location-spherical-beta c)
                   (%location-polar-radius c))
                 (location-spherical-p c)
                 (if (location-spherical-p c) (%location-polar-radius c))))
        ((numberp c)
         (setf c (floor c))
         (format nil "(~d ~d)" (point-h c) (point-v c)))))

(dolist (nickname-constructor
         '((make-location-object location-object object)
           (make-location-world location-world world)
           (make-location-ndc location-ndc ndc)
           (make-location-port location-port port)
           (make-location-rgba rgba rgb)
           (make-location-4 location-4 |4|)
           (make-location-3 location-3 |3|)
           (make-location-2 location-2 |2|)
           (make-location-polar location-polar polar)
           (make-location-spherical location-spherical spherical)))
  (destructuring-bind (constructor . nicknames) nickname-constructor
    (dolist (nickname nicknames)
      (setf (get nickname 'constructor)
            constructor))))

(defun location-constructor (class-nickname &aux constructor )
  (unless
    (setf constructor
          (get (find-symbol (etypecase class-nickname
                              (number (format nil "~a" class-nickname))
                              (symbol (string-upcase class-nickname)))
                            *location-package*)
               'constructor))
    (error "not a location type: ~s." class-nickname))
  constructor)

(defun make-location (&rest args)
  (declare (dynamic-extent args))
  (if (typep (first args) 'fixnum)
    (apply #'make-point args)
    (apply (location-constructor (first args)) (rest args))))

(defmethod make-load-form ((l location-2) &optional env)
  (declare (ignore env))
  (values
   `(make-location ',(type-of l)
	           :x ,(location-x l)
                   :y ,(location-y l)
                   ,@(when (location-3-p l) `(:z ,(location-z l)))
                   :h ,(location-h l))
   nil))

;; nb. this still uses the keyword-based constructors
(defun meta-parse-location (&key peek-char read-char read peek position
                                   &aux k1 k2 k3 k4 k5 v1 v2 v3 v4 v5 arg name)
  (declare (ignorable position))
  (flet ((first-dimension (name)
           (case name ((polar location-polar spherical location-spherical) :alpha) (rgba :r) (t :x)))
         (second-dimension (name)
           (case name ((polar location-polar) :radius) ((spherical location-spherical) :beta) (rgba :g) (t :y)))
         (third-dimension (name)
           (case name ((spherical location-spherical) :radius) ((|2| location-2) :h) (rgba :b) (t :z)))
         (fourth-dimension (name)
           (case name ((|4| location-4) :time) (rgba :a) (t :h)))
         (fifth-dimension (name)
           (ecase name ((|4| location-4) :h))))
    
    (meta:with-meta (:peek-char peek-char :read-char read-char :read read :peek peek :position position)
      (meta:match "[#\\(
               { [ $(symbolp arg) (setf name (if (find-if #'lower-case-p (string arg)) (intern (string-upcase arg)) arg))
                   $(identity arg) (setf k1 (first-dimension name) v1 arg)
                   $(identity arg) (setf k2 (second-dimension name) v2 arg)
                   { [ #\\) (return-from meta-parse-location (make-location name k1 v1 k2 v2)) ]
                     [ $(identity arg) (setf k3 (third-dimension name) v3 arg)
                       { [ #\\) (return-from meta-parse-location (make-location name k1 v1 k2 v2 k3 v3))]
                         [ $(identity arg) (setf k4 (fourth-dimension name) v4 arg)
                           { [ #\\) (return-from meta-parse-location (make-location name k1 v1 k2 v2 k3 v3 k4 v4)) ]
                             [ $(identity arg) (setf k5 (fifth-dimension name) v5 arg)
                               #\\) (return-from meta-parse-location (make-location name k1 v1 k2 v2 k3 v3 k4 v4 k5 v5))
                               ] }
                           ] }
                       ] }
                   ]
                 [ $(identity arg) (setf v1 arg)
                   $(identity arg) (setf v2 arg)
                   { [ #\\) (return-from meta-parse-location
                            (if (and (fixnump v1) (fixnump v2)) (make-point v1 v2) (make-location '|2| :x v1 :y v2))) ]
                     [ $(identity arg) (setf v3 arg)
                       { [ #\\) (return-from meta-parse-location (make-location '|3| :x v1 :y v2 :z v3)) ]
                         [ $(identity arg) (setf v4 arg)
                           #\\) (return-from meta-parse-location (make-location '|4| :x v1 :y v2 :z v3 :time v4))
                           ] }
                       ] }
                   ] } ]"
             ))))

(defGeneric parse-location (source &key &allow-other-keys)
  (:method ((stream stream) &key  &aux (last-read/peek nil))
           (labels ((p-c () (peek-char nil stream nil))
                    (r-c () (read-char stream nil))
                    (r () (if last-read/peek (shiftf last-read/peek nil) (read stream nil)))
                    (p () (if last-read/peek last-read/peek (setf last-read/peek (r))))
                    (pos (&optional position)
                      #-sbcl (stream-position stream position)
                      #+sbcl (file-position stream position)))          ; really works for files only, anyway
             (declare (dynamic-extent #'p-c #'r-c #'r #'p #'pos))
             (let ((l (meta-parse-location :peek-char #'p-c :read-char #'r-c :read #'r :peek #'p :position #'pos)))
               (cond (*read-suppress* t)
                     (l )
                     (t
                      (error "not a location in stream: ~s @ ~d." stream (pos stream)))))))
  (:method ((string string) &key (start 0 start-p) (end (length string)) &aux (index start) (last-read/peek nil))
           (labels ((p-c () (when (< index end) (char string index)))
                    (r-c () (when (< index end) (prog1 (char string index) (incf index))))
                    (r () (if last-read/peek (shiftf last-read/peek nil)
                              (multiple-value-bind (value new-index)
                                                   (read-from-string string nil nil :start index :end end)
                                (setf index new-index)
                                value)))
                    (p () (if last-read/peek last-read/peek (setf last-read/peek (r))))
                    (pos (&optional position) (if position (setf index position) index)))
             (declare (dynamic-extent #'p-c #'r-c #'r #'p #'pos))
             (or (meta-parse-location :peek-char #'p-c :read-char #'r-c :read #'r :peek #'p :position #'p)
                 (error "not a location: ~s~:[~; @ ~d~]." string start-p start)))))

(defun read-location (stream char arg)
  (declare (ignore char arg))
  ;; handle suppression indepent of parser, as that uses read
  ;; at least mcl-5.0 for suppressed case, return nil not (values)
  (cond (*read-suppress* (read stream)  nil)
        (t (parse-location stream))))


;; mcl replace the standard reader macro function for #@
(set-dispatch-macro-character #\# #\@ #'read-location)


(defVar +most-negative-location-world+
  (make-location-world :x most-negative-double-float :y most-negative-double-float :z most-negative-double-float))
(defVar +most-positive-location-world+
  (make-location-world :x most-positive-double-float :y most-positive-double-float :z most-positive-double-float))


;;;; 20030829 removed coercion functions



;;;; --------------------------------------------------------------------------
;;;; functions to construct or copy locations based upon
;;;; a canonical location type



(defun copy-location (c &optional result)
  (if (numberp c)
    c
    (if (location-2-p c)
      (progn (when (null result)
               (setq result (make-location (type-of c))))
	     (setf (location-x result) (location-x c)
		   (location-y result) (location-y c)
		   (location-h result) (location-h c))
             (if (location-3-p c)
               (setf (location-z result) (location-z c)))
	     result)
      c)))


#|
(parse-location "(0 0)")
(list #@(1 2) #@(rgba 1 2 3 4)
      #@(object 1 2 3) #@(|object| 1 2 3 1) #@(location-object 1 2)
      #@(world 1 2 3) #@(|world| 1 2 3 1) #@(location-world 1 2)
      #@(ndc 1 2 3) #@(|ndc| 1 2 3 1) #@(location-ndc 1 2)
      #@(port 1 2 3) #@(|port| 1 2 3 1) #@(location-port 1 2)
      #@(1 2 3 4) #@(location-4 1 2 3 4 5) #@(location-4 1 2 3 4 1)
      #@(1 2 3) #@(location-3 1 2 3 1)
      #@(1 2 ) #@(location-2 1 2 1)
      #@(polar 1 2) #@(|polar| 1 2) #@(location-polar 1 2)
      #@(spherical 1 2) #@(|spherical| 1 2 3) #@(location-spherical 1 2 3)
      )

(untrace location-class-nickname)
|#


;;;
;;; define a macro to pass single-float location coordinates w/o consing

#+digitool
(defun copy-record-to-double-coordinates (record x y &optional z h)
  (assert (typep x 'double-float))
  (assert (typep Y 'double-float))
  (macrolet ((copy-double-coordinate (from offset to)
               `(ccl::%get-double-float ,from ,offset ,to)))
    (copy-double-coordinate record 0 x)
    (copy-double-coordinate record 8 y)
    (when (typep z 'double-float)
      (copy-double-coordinate record 12 z)
      (when (typep h 'double-float)
        (copy-double-coordinate record 12 h))))
  nil)

#+clozure
(defun copy-record-to-double-coordinates (record x y &optional z h)
  (assert (typep x 'double-float))
  (assert (typep Y 'double-float))
  (macrolet ((copy-double-coordinate (from offset to)
               `(ccl::%copy-ptr-to-ivector ,from ,offset ,to (* 4 target::double-float.value-cell) 8)))
    (copy-double-coordinate record 0 x)
    (copy-double-coordinate record 8 y)
    (when (typep z 'double-float)
      (copy-double-coordinate record 12 z)
      (when (typep h 'double-float)
        (copy-double-coordinate record 12 h))))
  nil)

#-(or digitool clozure)
(warn "no definition for record->double-float copy.")


(defparameter *tmp-short* 3.0s0)

#+mcl
(ccl:defrecord :single-float-coordinate
  (:float :single-float :default 0.0s0))
#+mcl
(ccl:defrecord :double-float-coordinate
  (:float :double-float :default 0.0d0))

#+mcl
(defun %copy-location-to-short-coordinates (location x y &optional z h)
  (declare (type single-float x y))
  (assert (typep x 'single-float))
  (assert (typep Y 'single-float))
  (let ((tmp-double 0.0d0)
        (tmp-short 0.0s0))
    (declare (dynamic-extent tmp-double)
             (dynamic-extent tmp-short)
             (type double-float tmp-double)
             (type single-float tmp-short))
    (macrolet ((copy-short-coordinate (from to)
                 `(progn (setf tmp-short ,from)
                         (ccl::%set-ieee-single-float tmp-short %tmp-single-coordinate)
                         (ccl::%ref-ieee-single-float %tmp-single-coordinate ,to))))
      (rlet ((%tmp-single-coordinate :single-float-coordinate))
        (etypecase location
          (array
           (ecase (array-element-type location)
             ((short-float long-float double-float)
              (locally (declare (type location-vector location))
                (setf tmp-double (aref location 0)) ;; (return-from %copy-location-to-short-coordinates nil)
                (ccl::%set-ieee-single-float-from-double tmp-double %tmp-single-coordinate)
                (ccl::%ref-ieee-single-float %tmp-single-coordinate x)
                (setf tmp-double (aref location 1))
                (ccl::%set-ieee-single-float-from-double tmp-double %tmp-single-coordinate)
                (ccl::%ref-ieee-single-float %tmp-single-coordinate y)
                (when (typep z 'single-float)
                  (locally (declare (type single-float z))
                    (setf tmp-double (aref location 2))
                    (ccl::%set-ieee-single-float-from-double tmp-double %tmp-single-coordinate)
                    (ccl::%ref-ieee-single-float %tmp-single-coordinate z))
                  (when (typep h 'single-float)
                    (locally (declare (type single-float h))
                      (setf tmp-double (aref location 3))
                      (ccl::%set-ieee-single-float-from-double tmp-double %tmp-single-coordinate)
                      (ccl::%ref-ieee-single-float %tmp-single-coordinate h))))))
             (single-float
              (locally (declare (type short-location-vector location))
                (copy-short-coordinate (aref location 0) x)
                (copy-short-coordinate (aref location 1) y)
                (when (typep z 'single-float)
                  (locally (declare (type single-float z))
                    (copy-short-coordinate (aref location 2) z)
                    (when (typep h 'single-float)
                      (locally (declare (type single-float h))
                        (copy-short-coordinate (aref location 3) h)))))))))
          (location-ndc
           (locally (declare (type location-ndc location))
             (copy-short-coordinate (%location-ndc-x location) x)
             (copy-short-coordinate (%location-ndc-y location) y)
             (when (typep z 'single-float)
               (locally (declare (type single-float z))
                 (copy-short-coordinate (%location-ndc-z location) z)
                 (when (typep h 'single-float)
                   (locally (declare (type single-float h))
                     (copy-short-coordinate (%location-ndc-h location) h)))))))))))
  nil)

#-mcl
(defmacro %copy-location-to-short-coordinates (location x y &optional z h)
  (let ((l-var (gensym)))
    `(let ((,l-var ,location))
       (setf ,x (aref ,l-var 0))
       (setf ,y (aref ,l-var 1))
       ,@(when z
           `((setf ,z (aref ,l-var 2))
             ,@(when h
                 `((setf ,y (aref ,l-var 3)))))))))
         

(defmacro with-short-location-coordinates (bindings &rest body)
  "establish dynamic bindings for the components of a location-vector as short
   floats."
  (let* ((short-variables nil)
         (body-forms (member-if #'(lambda (form) (or (not (consp form))
                                                     (not (eq (first form) 'declare))))
                                body))
         (decl-forms (ldiff body body-forms)))
    `(let ,(reduce #'append
                   (mapcar #'(lambda (binding)
                               (destructuring-bind (location &rest coordinates) binding
                                 (declare (ignore location))
                                 (mapcar #'(lambda (name)
                                             (push name short-variables)
                                             `(,name 0.0s0))
                                         coordinates)))
                           bindings))
       (declare (type single-float ,@(reverse short-variables))
                (dynamic-extent ,@(reverse short-variables)))
       ,@decl-forms
       ,@(remove nil (mapcar #'(lambda (binding)
                                 (cons '%copy-location-to-short-coordinates binding))
                             bindings))
       ,@body-forms)))


;;;
;;; color definitions

(warn "expect value differences for gray/grey, green, maroon, and purple...")

(defgeneric find-rgba (designator)
  (:method ((designator symbol))
           (find-rgba (string designator)))
  (:method ((designator string))
           (gethash designator *rgba-registry*))
  (:method ((designator location-rgba))
           designator))

(defgeneric (setf find-rgba) (value designator)
  (:method ((value location-rgba) (designator string))
           (let ((old (gethash designator *rgba-registry*)))
             (when (and old (not (equalp old value)))
               (warn "redefining color: ~s: ~s -> ~s." designator old value)))
           (setf (gethash designator *rgba-registry*) value))
  (:method (value (designator symbol))
           (setf (find-rgba (string designator)) value)))

;;; svg colors
;;; svg spec

(flet ((svg-to-rgba (r g b) (rgba (/ r 255.0) (/ g 255.0) (/ b 255.0) 1.0)))
  (map nil #'(lambda (color-binding)
               (destructuring-bind (name r g b) color-binding
                 (setf (find-rgba (string name)) (svg-to-rgba r g b))))
       '((aliceblue 240 248 255) 
         (antiquewhite 250 235 215) 
         (aqua  0 255 255) 
         (aquamarine 127 255 212) 
         (azure 240 255 255) 
         (beige 245 245 220) 
         (bisque 255 228 196) 
         (black  0 0 0) 
         (blanchedalmond 255 235 205) 
         (blue  0 0 255) 
         (blueviolet 138 43 226) 
         (brown 165 42 42) 
         (burlywood 222 184 135) 
         (cadetblue  95 158 160) 
         (chartreuse 127 255 0) 
         (chocolate 210 105 30) 
         (coral 255 127 80) 
         (cornflowerblue 100 149 237) 
         (cornsilk 255 248 220) 
         (crimson 220 20 60) 
         (cyan  0 255 255) 
         (darkblue  0 0 139) 
         (darkcyan  0 139 139) 
         (darkgoldenrod 184 134 11) 
         (darkgray 169 169 169) 
         (darkgreen  0 100 0) 
         (darkgrey 169 169 169) 
         (darkkhaki 189 183 107) 
         (darkmagenta 139 0 139) 
         (darkolivegreen  85 107 47) 
         (darkorange 255 140 0) 
         (darkorchid 153 50 204) 
         (darkred 139 0 0) 
         (darksalmon 233 150 122) 
         (darkseagreen 143 188 143) 
         (darkslateblue  72 61 139) 
         (darkslategray  47 79 79) 
         (darkslategrey  47 79 79) 
         (darkturquoise  0 206 209) 
         (darkviolet 148 0 211) 
         (deeppink 255 20 147) 
         (deepskyblue  0 191 255) 
         (dimgray 105 105 105) 
         (dimgrey 105 105 105) 
         (dodgerblue  30 144 255) 
         (firebrick 178 34 34) 
         (floralwhite 255 250 240) 
         (forestgreen  34 139 34) 
         (fuchsia 255 0 255) 
         (gainsboro 220 220 220) 
         (ghostwhite 248 248 255) 
         (gold 255 215 0) 
         (goldenrod 218 165 32) 
         (gray 128 128 128) 
         (grey 128 128 128) 
         (green  0 128 0) 
         (greenyellow 173 255 47) 
         (honeydew 240 255 240) 
         (hotpink 255 105 180) 
         (indianred 205 92 92) 
         (indigo  75 0 130) 
         (ivory 255 255 240) 
         (khaki 240 230 140) 
         (lavender 230 230 250) 
         (lavenderblush 255 240 245) 
         (lightpink 255 182 193) 
         (lightsalmon 255 160 122) 
         (lightseagreen  32 178 170) 
         (lightskyblue 135 206 250) 
         (lightslategray 119 136 153) 
         (lightslategrey 119 136 153) 
         (lightsteelblue 176 196 222) 
         (lightyellow 255 255 224) 
         (lime  0 255 0) 
         (limegreen  50 205 50) 
         (linen 250 240 230) 
         (lawngreen 124 252 0) 
         (lemonchiffon 255 250 205) 
         (lightblue 173 216 230) 
         (lightcoral 240 128 128) 
         (lightcyan 224 255 255) 
         (lightgoldenrodyellow 250 250 210) 
         (lightgray 211 211 211) 
         (lightgreen 144 238 144) 
         (lightgrey 211 211 211) 
         (magenta 255 0 255) 
         (maroon 128 0 0) 
         (mediumaquamarine 102 205 170) 
         (mediumblue  0 0 205) 
         (mediumorchid 186 85 211)
         (mediumpurple 147 112 219) 
         (mediumseagreen  60 179 113) 
         (mediumslateblue 123 104 238) 
         (mediumspringgreen 0 250 154) 
         (mediumturquoise  72 209 204) 
         (mediumvioletred 199 21 133) 
         (midnightblue  25 25 112) 
         (mintcream 245 255 250) 
         (mistyrose 255 228 225) 
         (moccasin 255 228 181) 
         (navajowhite 255 222 173) 
         (navy  0 0 128) 
         (oldlace 253 245 230) 
         (olive 128 128 0) 
         (olivedrab 107 142 35) 
         (orange 255 165 0) 
         (orangered 255 69 0) 
         (orchid 218 112 214) 
         (palegoldenrod 238 232 170) 
         (palegreen 152 251 152) 
         (paleturquoise 175 238 238) 
         (palevioletred 219 112 147) 
         (papayawhip 255 239 213) 
         (peachpuff 255 218 185) 
         (peru 205 133 63) 
         (pink 255 192 203) 
         (plum 221 160 221) 
         (powderblue 176 224 230) 
         (purple 128 0 128) 
         (red 255 0 0) 
         (rosybrown 188 143 143) 
         (royalblue  65 105 225) 
         (saddlebrown 139 69 19) 
         (salmon 250 128 114) 
         (sandybrown 244 164 96) 
         (seagreen  46 139 87) 
         (seashell 255 245 238) 
         (sienna 160 82 45) 
         (silver 192 192 192) 
         (skyblue 135 206 235) 
         (slateblue 106 90 205) 
         (slategray 112 128 144) 
         (slategrey 112 128 144) 
         (snow 255 250 250) 
         (springgreen  0 255 127) 
         (steelblue  70 130 180) 
         (tan 210 180 140) 
         (teal  0 128 128)
         (thistle 216 191 216) 
         (tomato 255 99 71) 
         (turquoise  64 224 208) 
         (violet 238 130 238) 
         (wheat 245 222 179) 
         (white 255 255 255) 
         (whitesmoke 245 245 245) 
         (yellow 255 255 0) 
         (yellowgreen 154 205 50)
         )))

;;; html colors
;;; html 4.0 spec

(flet ((html-to-rgba (value)
         (setf value (parse-integer value :start 1 :radix 16))
         (rgba (/ (ash value -16) 255.0) (/ (logand #xff (ash value -8)) 255.0) (/ (logand #xff value) 255.0) 1.0)))
  (map nil #'(lambda (color-binding)
               (destructuring-bind (name value) color-binding
                 (setf (find-rgba (string name)) (html-to-rgba value))))
       '((Black "#000000")
         (Green "#008000")
	 (Silver "#C0C0C0")
         (Lime "#00FF00") 
	 (Gray "#808080")
         (Olive "#808000") 
	 (White "#FFFFFF")
         (Yellow "#FFFF00") 
	 (Maroon "#800000")
         (Navy "#000080") 
	 (Red "#FF0000")
         (Blue "#0000FF")
	 (Purple "#800080")
         (Teal "#008080")
	 (Fuchsia "#FF00FF")
         (Aqua "#00FFFF"))))

;;; x window system
;;; /usr/lib/X11/rgb.txt

(flet ((x-to-rgba (r g b)  (rgba (/ r 255.0) (/ g 255.0) (/ b 255.0) 1.0)))
  (map nil #'(lambda (color-binding)
               (destructuring-bind (r g b name) color-binding
                 (setf (find-rgba name) (x-to-rgba r g b))))
       '((255 250 250 "snow")
         (248 248 255 "ghost white")
         (248 248 255 "GhostWhite")
         (245 245 245 "white smoke")
         (245 245 245 "WhiteSmoke")
         (220 220 220 "gainsboro")
         (255 250 240 "floral white")
         (255 250 240 "FloralWhite")
         (253 245 230 "old lace")
         (253 245 230 "OldLace")
         (250 240 230 "linen")
         (250 235 215 "antique white")
         (250 235 215 "AntiqueWhite")
         (255 239 213 "papaya whip")
         (255 239 213 "PapayaWhip")
         (255 235 205 "blanched almond")
         (255 235 205 "BlanchedAlmond")
         (255 228 196 "bisque")
         (255 218 185 "peach puff")
         (255 218 185 "PeachPuff")
         (255 222 173 "navajo white")
         (255 222 173 "NavajoWhite")
         (255 228 181 "moccasin")
         (255 248 220 "cornsilk")
         (255 255 240 "ivory")
         (255 250 205 "lemon chiffon")
         (255 250 205 "LemonChiffon")
         (255 245 238 "seashell")
         (240 255 240 "honeydew")
         (245 255 250 "mint cream")
         (245 255 250 "MintCream")
         (240 255 255 "azure")
         (240 248 255 "alice blue")
         (240 248 255 "AliceBlue")
         (230 230 250 "lavender")
         (255 240 245 "lavender blush")
         (255 240 245 "LavenderBlush")
         (255 228 225 "misty rose")
         (255 228 225 "MistyRose")
         (255 255 255 "white")
         (  0   0   0 "black")
         ( 47  79  79 "dark slate gray")
         ( 47  79  79 "DarkSlateGray")
         ( 47  79  79 "dark slate grey")
         ( 47  79  79 "DarkSlateGrey")
         (105 105 105 "dim gray")
         (105 105 105 "DimGray")
         (105 105 105 "dim grey")
         (105 105 105 "DimGrey")
         (112 128 144 "slate gray")
         (112 128 144 "SlateGray")
         (112 128 144 "slate grey")
         (112 128 144 "SlateGrey")
         (119 136 153 "light slate gray")
         (119 136 153 "LightSlateGray")
         (119 136 153 "light slate grey")
         (119 136 153 "LightSlateGrey")
         (190 190 190 "gray")
         (190 190 190 "grey")
         (211 211 211 "light grey")
         (211 211 211 "LightGrey")
         (211 211 211 "light gray")
         (211 211 211 "LightGray")
         ( 25  25 112 "midnight blue")
         ( 25  25 112 "MidnightBlue")
         (  0   0 128 "navy")
         (  0   0 128 "navy blue")
         (  0   0 128 "NavyBlue")
         (100 149 237 "cornflower blue")
         (100 149 237 "CornflowerBlue")
         ( 72  61 139 "dark slate blue")
         ( 72  61 139 "DarkSlateBlue")
         (106  90 205 "slate blue")
         (106  90 205 "SlateBlue")
         (123 104 238 "medium slate blue")
         (123 104 238 "MediumSlateBlue")
         (132 112 255 "light slate blue")
         (132 112 255 "LightSlateBlue")
         (  0   0 205 "medium blue")
         (  0   0 205 "MediumBlue")
         ( 65 105 225 "royal blue")
         ( 65 105 225 "RoyalBlue")
         (  0   0 255 "blue")
         ( 30 144 255 "dodger blue")
         ( 30 144 255 "DodgerBlue")
         (  0 191 255 "deep sky blue")
         (  0 191 255 "DeepSkyBlue")
         (135 206 235 "sky blue")
         (135 206 235 "SkyBlue")
         (135 206 250 "light sky blue")
         (135 206 250 "LightSkyBlue")
         ( 70 130 180 "steel blue")
         ( 70 130 180 "SteelBlue")
         (176 196 222 "light steel blue")
         (176 196 222 "LightSteelBlue")
         (173 216 230 "light blue")
         (173 216 230 "LightBlue")
         (176 224 230 "powder blue")
         (176 224 230 "PowderBlue")
         (175 238 238 "pale turquoise")
         (175 238 238 "PaleTurquoise")
         (  0 206 209 "dark turquoise")
         (  0 206 209 "DarkTurquoise")
         ( 72 209 204 "medium turquoise")
         ( 72 209 204 "MediumTurquoise")
         ( 64 224 208 "turquoise")
         (  0 255 255 "cyan")
         (224 255 255 "light cyan")
         (224 255 255 "LightCyan")
         ( 95 158 160 "cadet blue")
         ( 95 158 160 "CadetBlue")
         (102 205 170 "medium aquamarine")
         (102 205 170 "MediumAquamarine")
         (127 255 212 "aquamarine")
         (  0 100   0 "dark green")
         (  0 100   0 "DarkGreen")
         ( 85 107  47 "dark olive green")
         ( 85 107  47 "DarkOliveGreen")
         (143 188 143 "dark sea green")
         (143 188 143 "DarkSeaGreen")
         ( 46 139  87 "sea green")
         ( 46 139  87 "SeaGreen")
         ( 60 179 113 "medium sea green")
         ( 60 179 113 "MediumSeaGreen")
         ( 32 178 170 "light sea green")
         ( 32 178 170 "LightSeaGreen")
         (152 251 152 "pale green")
         (152 251 152 "PaleGreen")
         (  0 255 127 "spring green")
         (  0 255 127 "SpringGreen")
         (124 252   0 "lawn green")
         (124 252   0 "LawnGreen")
         (  0 255   0 "green")
         (127 255   0 "chartreuse")
         (  0 250 154 "medium spring green")
         (  0 250 154 "MediumSpringGreen")
         (173 255  47 "green yellow")
         (173 255  47 "GreenYellow")
         ( 50 205  50 "lime green")
         ( 50 205  50 "LimeGreen")
         (154 205  50 "yellow green")
         (154 205  50 "YellowGreen")
         ( 34 139  34 "forest green")
         ( 34 139  34 "ForestGreen")
         (107 142  35 "olive drab")
         (107 142  35 "OliveDrab")
         (189 183 107 "dark khaki")
         (189 183 107 "DarkKhaki")
         (240 230 140 "khaki")
         (238 232 170 "pale goldenrod")
         (238 232 170 "PaleGoldenrod")
         (250 250 210 "light goldenrod yellow")
         (250 250 210 "LightGoldenrodYellow")
         (255 255 224 "light yellow")
         (255 255 224 "LightYellow")
         (255 255   0 "yellow")
         (255 215   0 "gold")
         (238 221 130 "light goldenrod")
         (238 221 130 "LightGoldenrod")
         (218 165  32 "goldenrod")
         (184 134  11 "dark goldenrod")
         (184 134  11 "DarkGoldenrod")
         (188 143 143 "rosy brown")
         (188 143 143 "RosyBrown")
         (205  92  92 "indian red")
         (205  92  92 "IndianRed")
         (139  69  19 "saddle brown")
         (139  69  19 "SaddleBrown")
         (160  82  45 "sienna")
         (205 133  63 "peru")
         (222 184 135 "burlywood")
         (245 245 220 "beige")
         (245 222 179 "wheat")
         (244 164  96 "sandy brown")
         (244 164  96 "SandyBrown")
         (210 180 140 "tan")
         (210 105  30 "chocolate")
         (178  34  34 "firebrick")
         (165  42  42 "brown")
         (233 150 122 "dark salmon")
         (233 150 122 "DarkSalmon")
         (250 128 114 "salmon")
         (255 160 122 "light salmon")
         (255 160 122 "LightSalmon")
         (255 165   0 "orange")
         (255 140   0 "dark orange")
         (255 140   0 "DarkOrange")
         (255 127  80 "coral")
         (240 128 128 "light coral")
         (240 128 128 "LightCoral")
         (255  99  71 "tomato")
         (255  69   0 "orange red")
         (255  69   0 "OrangeRed")
         (255   0   0 "red")
         (255 105 180 "hot pink")
         (255 105 180 "HotPink")
         (255  20 147 "deep pink")
         (255  20 147 "DeepPink")
         (255 192 203 "pink")
         (255 182 193 "light pink")
         (255 182 193 "LightPink")
         (219 112 147 "pale violet red")
         (219 112 147 "PaleVioletRed")
         (176  48  96 "maroon")
         (199  21 133 "medium violet red")
         (199  21 133 "MediumVioletRed")
         (208  32 144 "violet red")
         (208  32 144 "VioletRed")
         (255   0 255 "magenta")
         (238 130 238 "violet")
         (221 160 221 "plum")
         (218 112 214 "orchid")
         (186  85 211 "medium orchid")
         (186  85 211 "MediumOrchid")
         (153  50 204 "dark orchid")
         (153  50 204 "DarkOrchid")
         (148   0 211 "dark violet")
         (148   0 211 "DarkViolet")
         (138  43 226 "blue violet")
         (138  43 226 "BlueViolet")
         (160  32 240 "purple")
         (147 112 219 "medium purple")
         (147 112 219 "MediumPurple")
         (216 191 216 "thistle")
         (255 250 250 "snow1")
         (238 233 233 "snow2")
         (205 201 201 "snow3")
         (139 137 137 "snow4")
         (255 245 238 "seashell1")
         (238 229 222 "seashell2")
         (205 197 191 "seashell3")
         (139 134 130 "seashell4")
         (255 239 219 "AntiqueWhite1")
         (238 223 204 "AntiqueWhite2")
         (205 192 176 "AntiqueWhite3")
         (139 131 120 "AntiqueWhite4")
         (255 228 196 "bisque1")
         (238 213 183 "bisque2")
         (205 183 158 "bisque3")
         (139 125 107 "bisque4")
         (255 218 185 "PeachPuff1")
         (238 203 173 "PeachPuff2")
         (205 175 149 "PeachPuff3")
         (139 119 101 "PeachPuff4")
         (255 222 173 "NavajoWhite1")
         (238 207 161 "NavajoWhite2")
         (205 179 139 "NavajoWhite3")
         (139 121	 94 "NavajoWhite4")
         (255 250 205 "LemonChiffon1")
         (238 233 191 "LemonChiffon2")
         (205 201 165 "LemonChiffon3")
         (139 137 112 "LemonChiffon4")
         (255 248 220 "cornsilk1")
         (238 232 205 "cornsilk2")
         (205 200 177 "cornsilk3")
         (139 136 120 "cornsilk4")
         (255 255 240 "ivory1")
         (238 238 224 "ivory2")
         (205 205 193 "ivory3")
         (139 139 131 "ivory4")
         (240 255 240 "honeydew1")
         (224 238 224 "honeydew2")
         (193 205 193 "honeydew3")
         (131 139 131 "honeydew4")
         (255 240 245 "LavenderBlush1")
         (238 224 229 "LavenderBlush2")
         (205 193 197 "LavenderBlush3")
         (139 131 134 "LavenderBlush4")
         (255 228 225 "MistyRose1")
         (238 213 210 "MistyRose2")
         (205 183 181 "MistyRose3")
         (139 125 123 "MistyRose4")
         (240 255 255 "azure1")
         (224 238 238 "azure2")
         (193 205 205 "azure3")
         (131 139 139 "azure4")
         (131 111 255 "SlateBlue1")
         (122 103 238 "SlateBlue2")
         (105  89 205 "SlateBlue3")
         ( 71  60 139 "SlateBlue4")
         ( 72 118 255 "RoyalBlue1")
         ( 67 110 238 "RoyalBlue2")
         ( 58  95 205 "RoyalBlue3")
         ( 39  64 139 "RoyalBlue4")
         (  0   0 255 "blue1")
         (  0   0 238 "blue2")
         (  0   0 205 "blue3")
         (  0   0 139 "blue4")
         ( 30 144 255 "DodgerBlue1")
         ( 28 134 238 "DodgerBlue2")
         ( 24 116 205 "DodgerBlue3")
         ( 16  78 139 "DodgerBlue4")
         ( 99 184 255 "SteelBlue1")
         ( 92 172 238 "SteelBlue2")
         ( 79 148 205 "SteelBlue3")
         ( 54 100 139 "SteelBlue4")
         (  0 191 255 "DeepSkyBlue1")
         (  0 178 238 "DeepSkyBlue2")
         (  0 154 205 "DeepSkyBlue3")
         (  0 104 139 "DeepSkyBlue4")
         (135 206 255 "SkyBlue1")
         (126 192 238 "SkyBlue2")
         (108 166 205 "SkyBlue3")
         ( 74 112 139 "SkyBlue4")
         (176 226 255 "LightSkyBlue1")
         (164 211 238 "LightSkyBlue2")
         (141 182 205 "LightSkyBlue3")
         ( 96 123 139 "LightSkyBlue4")
         (198 226 255 "SlateGray1")
         (185 211 238 "SlateGray2")
         (159 182 205 "SlateGray3")
         (108 123 139 "SlateGray4")
         (202 225 255 "LightSteelBlue1")
         (188 210 238 "LightSteelBlue2")
         (162 181 205 "LightSteelBlue3")
         (110 123 139 "LightSteelBlue4")
         (191 239 255 "LightBlue1")
         (178 223 238 "LightBlue2")
         (154 192 205 "LightBlue3")
         (104 131 139 "LightBlue4")
         (224 255 255 "LightCyan1")
         (209 238 238 "LightCyan2")
         (180 205 205 "LightCyan3")
         (122 139 139 "LightCyan4")
         (187 255 255 "PaleTurquoise1")
         (174 238 238 "PaleTurquoise2")
         (150 205 205 "PaleTurquoise3")
         (102 139 139 "PaleTurquoise4")
         (152 245 255 "CadetBlue1")
         (142 229 238 "CadetBlue2")
         (122 197 205 "CadetBlue3")
         ( 83 134 139 "CadetBlue4")
         (  0 245 255 "turquoise1")
         (  0 229 238 "turquoise2")
         (  0 197 205 "turquoise3")
         (  0 134 139 "turquoise4")
         (  0 255 255 "cyan1")
         (  0 238 238 "cyan2")
         (  0 205 205 "cyan3")
         (  0 139 139 "cyan4")
         (151 255 255 "DarkSlateGray1")
         (141 238 238 "DarkSlateGray2")
         (121 205 205 "DarkSlateGray3")
         ( 82 139 139 "DarkSlateGray4")
         (127 255 212 "aquamarine1")
         (118 238 198 "aquamarine2")
         (102 205 170 "aquamarine3")
         ( 69 139 116 "aquamarine4")
         (193 255 193 "DarkSeaGreen1")
         (180 238 180 "DarkSeaGreen2")
         (155 205 155 "DarkSeaGreen3")
         (105 139 105 "DarkSeaGreen4")
         ( 84 255 159 "SeaGreen1")
         ( 78 238 148 "SeaGreen2")
         ( 67 205 128 "SeaGreen3")
         ( 46 139	 87 "SeaGreen4")
         (154 255 154 "PaleGreen1")
         (144 238 144 "PaleGreen2")
         (124 205 124 "PaleGreen3")
         ( 84 139	 84 "PaleGreen4")
         (  0 255 127 "SpringGreen1")
         (  0 238 118 "SpringGreen2")
         (  0 205 102 "SpringGreen3")
         (  0 139	 69 "SpringGreen4")
         (  0 255	  0 "green1")
         (  0 238	  0 "green2")
         (  0 205	  0 "green3")
         (  0 139	  0 "green4")
         (127 255	  0 "chartreuse1")
         (118 238	  0 "chartreuse2")
         (102 205	  0 "chartreuse3")
         ( 69 139	  0 "chartreuse4")
         (192 255	 62 "OliveDrab1")
         (179 238	 58 "OliveDrab2")
         (154 205	 50 "OliveDrab3")
         (105 139	 34 "OliveDrab4")
         (202 255 112 "DarkOliveGreen1")
         (188 238 104 "DarkOliveGreen2")
         (162 205	 90 "DarkOliveGreen3")
         (110 139	 61 "DarkOliveGreen4")
         (255 246 143 "khaki1")
         (238 230 133 "khaki2")
         (205 198 115 "khaki3")
         (139 134	 78 "khaki4")
         (255 236 139 "LightGoldenrod1")
         (238 220 130 "LightGoldenrod2")
         (205 190 112 "LightGoldenrod3")
         (139 129	 76 "LightGoldenrod4")
         (255 255 224 "LightYellow1")
         (238 238 209 "LightYellow2")
         (205 205 180 "LightYellow3")
         (139 139 122 "LightYellow4")
         (255 255	  0 "yellow1")
         (238 238	  0 "yellow2")
         (205 205	  0 "yellow3")
         (139 139	  0 "yellow4")
         (255 215	  0 "gold1")
         (238 201	  0 "gold2")
         (205 173	  0 "gold3")
         (139 117	  0 "gold4")
         (255 193	 37 "goldenrod1")
         (238 180	 34 "goldenrod2")
         (205 155	 29 "goldenrod3")
         (139 105	 20 "goldenrod4")
         (255 185	 15 "DarkGoldenrod1")
         (238 173	 14 "DarkGoldenrod2")
         (205 149	 12 "DarkGoldenrod3")
         (139 101	  8 "DarkGoldenrod4")
         (255 193 193 "RosyBrown1")
         (238 180 180 "RosyBrown2")
         (205 155 155 "RosyBrown3")
         (139 105 105 "RosyBrown4")
         (255 106 106 "IndianRed1")
         (238  99	 99 "IndianRed2")
         (205  85	 85 "IndianRed3")
         (139  58	 58 "IndianRed4")
         (255 130	 71 "sienna1")
         (238 121	 66 "sienna2")
         (205 104	 57 "sienna3")
         (139  71	 38 "sienna4")
         (255 211 155 "burlywood1")
         (238 197 145 "burlywood2")
         (205 170 125 "burlywood3")
         (139 115	 85 "burlywood4")
         (255 231 186 "wheat1")
         (238 216 174 "wheat2")
         (205 186 150 "wheat3")
         (139 126 102 "wheat4")
         (255 165	 79 "tan1")
         (238 154	 73 "tan2")
         (205 133	 63 "tan3")
         (139  90	 43 "tan4")
         (255 127	 36 "chocolate1")
         (238 118	 33 "chocolate2")
         (205 102	 29 "chocolate3")
         (139  69	 19 "chocolate4")
         (255  48	 48 "firebrick1")
         (238  44	 44 "firebrick2")
         (205  38	 38 "firebrick3")
         (139  26	 26 "firebrick4")
         (255  64	 64 "brown1")
         (238  59	 59 "brown2")
         (205  51	 51 "brown3")
         (139  35	 35 "brown4")
         (255 140 105 "salmon1")
         (238 130	 98 "salmon2")
         (205 112	 84 "salmon3")
         (139  76	 57 "salmon4")
         (255 160 122 "LightSalmon1")
         (238 149 114 "LightSalmon2")
         (205 129	 98 "LightSalmon3")
         (139  87	 66 "LightSalmon4")
         (255 165	  0 "orange1")
         (238 154	  0 "orange2")
         (205 133	  0 "orange3")
         (139  90	  0 "orange4")
         (255 127	  0 "DarkOrange1")
         (238 118	  0 "DarkOrange2")
         (205 102	  0 "DarkOrange3")
         (139  69	  0 "DarkOrange4")
         (255 114	 86 "coral1")
         (238 106	 80 "coral2")
         (205  91	 69 "coral3")
         (139  62	 47 "coral4")
         (255  99	 71 "tomato1")
         (238  92	 66 "tomato2")
         (205  79	 57 "tomato3")
         (139  54	 38 "tomato4")
         (255  69	  0 "OrangeRed1")
         (238  64	  0 "OrangeRed2")
         (205  55	  0 "OrangeRed3")
         (139  37	  0 "OrangeRed4")
         (255   0	  0 "red1")
         (238   0	  0 "red2")
         (205   0	  0 "red3")
         (139   0	  0 "red4")
         (255  20 147 "DeepPink1")
         (238  18 137 "DeepPink2")
         (205  16 118 "DeepPink3")
         (139  10	 80 "DeepPink4")
         (255 110 180 "HotPink1")
         (238 106 167 "HotPink2")
         (205  96 144 "HotPink3")
         (139  58  98 "HotPink4")
         (255 181 197 "pink1")
         (238 169 184 "pink2")
         (205 145 158 "pink3")
         (139  99 108 "pink4")
         (255 174 185 "LightPink1")
         (238 162 173 "LightPink2")
         (205 140 149 "LightPink3")
         (139  95 101 "LightPink4")
         (255 130 171 "PaleVioletRed1")
         (238 121 159 "PaleVioletRed2")
         (205 104 137 "PaleVioletRed3")
         (139  71	 93 "PaleVioletRed4")
         (255  52 179 "maroon1")
         (238  48 167 "maroon2")
         (205  41 144 "maroon3")
         (139  28	 98 "maroon4")
         (255  62 150 "VioletRed1")
         (238  58 140 "VioletRed2")
         (205  50 120 "VioletRed3")
         (139  34	 82 "VioletRed4")
         (255   0 255 "magenta1")
         (238   0 238 "magenta2")
         (205   0 205 "magenta3")
         (139   0 139 "magenta4")
         (255 131 250 "orchid1")
         (238 122 233 "orchid2")
         (205 105 201 "orchid3")
         (139  71 137 "orchid4")
         (255 187 255 "plum1")
         (238 174 238 "plum2")
         (205 150 205 "plum3")
         (139 102 139 "plum4")
         (224 102 255 "MediumOrchid1")
         (209  95 238 "MediumOrchid2")
         (180  82 205 "MediumOrchid3")
         (122  55 139 "MediumOrchid4")
         (191  62 255 "DarkOrchid1")
         (178  58 238 "DarkOrchid2")
         (154  50 205 "DarkOrchid3")
         (104  34 139 "DarkOrchid4")
         (155  48 255 "purple1")
         (145  44 238 "purple2")
         (125  38 205 "purple3")
         ( 85  26 139 "purple4")
         (171 130 255 "MediumPurple1")
         (159 121 238 "MediumPurple2")
         (137 104 205 "MediumPurple3")
         ( 93  71 139 "MediumPurple4")
         (255 225 255 "thistle1")
         (238 210 238 "thistle2")
         (205 181 205 "thistle3")
         (139 123 139 "thistle4")
         (  0   0   0 "gray0")
         (  0   0   0 "grey0")
         (  3   3   3 "gray1")
         (  3   3   3 "grey1")
         (  5   5   5 "gray2")
         (  5   5   5 "grey2")
         (  8   8   8 "gray3")
         (  8   8   8 "grey3")
         ( 10  10  10 "gray4")
         ( 10  10  10 "grey4")
         ( 13  13  13 "gray5")
         ( 13  13  13 "grey5")
         ( 15  15  15 "gray6")
         ( 15  15  15 "grey6")
         ( 18  18  18 "gray7")
         ( 18  18  18 "grey7")
         ( 20  20  20 "gray8")
         ( 20  20  20 "grey8")
         ( 23  23  23 "gray9")
         ( 23  23  23 "grey9")
         ( 26  26  26 "gray10")
         ( 26  26  26 "grey10")
         ( 28  28  28 "gray11")
         ( 28  28  28 "grey11")
         ( 31  31  31 "gray12")
         ( 31  31  31 "grey12")
         ( 33  33  33 "gray13")
         ( 33  33  33 "grey13")
         ( 36  36  36 "gray14")
         ( 36  36  36 "grey14")
         ( 38  38  38 "gray15")
         ( 38  38  38 "grey15")
         ( 41  41  41 "gray16")
         ( 41  41  41 "grey16")
         ( 43  43  43 "gray17")
         ( 43  43  43 "grey17")
         ( 46  46  46 "gray18")
         ( 46  46  46 "grey18")
         ( 48  48  48 "gray19")
         ( 48  48  48 "grey19")
         ( 51  51  51 "gray20")
         ( 51  51  51 "grey20")
         ( 54  54  54 "gray21")
         ( 54  54  54 "grey21")
         ( 56  56  56 "gray22")
         ( 56  56  56 "grey22")
         ( 59  59  59 "gray23")
         ( 59  59  59 "grey23")
         ( 61  61  61 "gray24")
         ( 61  61  61 "grey24")
         ( 64  64  64 "gray25")
         ( 64  64  64 "grey25")
         ( 66  66  66 "gray26")
         ( 66  66  66 "grey26")
         ( 69  69  69 "gray27")
         ( 69  69  69 "grey27")
         ( 71  71  71 "gray28")
         ( 71  71  71 "grey28")
         ( 74  74  74 "gray29")
         ( 74  74  74 "grey29")
         ( 77  77  77 "gray30")
         ( 77  77  77 "grey30")
         ( 79  79  79 "gray31")
         ( 79  79  79 "grey31")
         ( 82  82  82 "gray32")
         ( 82  82  82 "grey32")
         ( 84  84  84 "gray33")
         ( 84  84  84 "grey33")
         ( 87  87  87 "gray34")
         ( 87  87  87 "grey34")
         ( 89  89  89 "gray35")
         ( 89  89  89 "grey35")
         ( 92  92  92 "gray36")
         ( 92  92  92 "grey36")
         ( 94  94  94 "gray37")
         ( 94  94  94 "grey37")
         ( 97  97  97 "gray38")
         ( 97  97  97 "grey38")
         ( 99  99  99 "gray39")
         ( 99  99  99 "grey39")
         (102 102 102 "gray40")
         (102 102 102 "grey40")
         (105 105 105 "gray41")
         (105 105 105 "grey41")
         (107 107 107 "gray42")
         (107 107 107 "grey42")
         (110 110 110 "gray43")
         (110 110 110 "grey43")
         (112 112 112 "gray44")
         (112 112 112 "grey44")
         (115 115 115 "gray45")
         (115 115 115 "grey45")
         (117 117 117 "gray46")
         (117 117 117 "grey46")
         (120 120 120 "gray47")
         (120 120 120 "grey47")
         (122 122 122 "gray48")
         (122 122 122 "grey48")
         (125 125 125 "gray49")
         (125 125 125 "grey49")
         (127 127 127 "gray50")
         (127 127 127 "grey50")
         (130 130 130 "gray51")
         (130 130 130 "grey51")
         (133 133 133 "gray52")
         (133 133 133 "grey52")
         (135 135 135 "gray53")
         (135 135 135 "grey53")
         (138 138 138 "gray54")
         (138 138 138 "grey54")
         (140 140 140 "gray55")
         (140 140 140 "grey55")
         (143 143 143 "gray56")
         (143 143 143 "grey56")
         (145 145 145 "gray57")
         (145 145 145 "grey57")
         (148 148 148 "gray58")
         (148 148 148 "grey58")
         (150 150 150 "gray59")
         (150 150 150 "grey59")
         (153 153 153 "gray60")
         (153 153 153 "grey60")
         (156 156 156 "gray61")
         (156 156 156 "grey61")
         (158 158 158 "gray62")
         (158 158 158 "grey62")
         (161 161 161 "gray63")
         (161 161 161 "grey63")
         (163 163 163 "gray64")
         (163 163 163 "grey64")
         (166 166 166 "gray65")
         (166 166 166 "grey65")
         (168 168 168 "gray66")
         (168 168 168 "grey66")
         (171 171 171 "gray67")
         (171 171 171 "grey67")
         (173 173 173 "gray68")
         (173 173 173 "grey68")
         (176 176 176 "gray69")
         (176 176 176 "grey69")
         (179 179 179 "gray70")
         (179 179 179 "grey70")
         (181 181 181 "gray71")
         (181 181 181 "grey71")
         (184 184 184 "gray72")
         (184 184 184 "grey72")
         (186 186 186 "gray73")
         (186 186 186 "grey73")
         (189 189 189 "gray74")
         (189 189 189 "grey74")
         (191 191 191 "gray75")
         (191 191 191 "grey75")
         (194 194 194 "gray76")
         (194 194 194 "grey76")
         (196 196 196 "gray77")
         (196 196 196 "grey77")
         (199 199 199 "gray78")
         (199 199 199 "grey78")
         (201 201 201 "gray79")
         (201 201 201 "grey79")
         (204 204 204 "gray80")
         (204 204 204 "grey80")
         (207 207 207 "gray81")
         (207 207 207 "grey81")
         (209 209 209 "gray82")
         (209 209 209 "grey82")
         (212 212 212 "gray83")
         (212 212 212 "grey83")
         (214 214 214 "gray84")
         (214 214 214 "grey84")
         (217 217 217 "gray85")
         (217 217 217 "grey85")
         (219 219 219 "gray86")
         (219 219 219 "grey86")
         (222 222 222 "gray87")
         (222 222 222 "grey87")
         (224 224 224 "gray88")
         (224 224 224 "grey88")
         (227 227 227 "gray89")
         (227 227 227 "grey89")
         (229 229 229 "gray90")
         (229 229 229 "grey90")
         (232 232 232 "gray91")
         (232 232 232 "grey91")
         (235 235 235 "gray92")
         (235 235 235 "grey92")
         (237 237 237 "gray93")
         (237 237 237 "grey93")
         (240 240 240 "gray94")
         (240 240 240 "grey94")
         (242 242 242 "gray95")
         (242 242 242 "grey95")
         (245 245 245 "gray96")
         (245 245 245 "grey96")
         (247 247 247 "gray97")
         (247 247 247 "grey97")
         (250 250 250 "gray98")
         (250 250 250 "grey98")
         (252 252 252 "gray99")
         (252 252 252 "grey99")
         (255 255 255 "gray100")
         (255 255 255 "grey100")
         (169 169 169 "dark grey")
         (169 169 169 "DarkGrey")
         (169 169 169 "dark gray")
         (169 169 169 "DarkGray")
         (0     0 139 "dark blue")
         (0     0 139 "DarkBlue")
         (0   139 139 "dark cyan")
         (0   139 139 "DarkCyan")
         (139   0 139 "dark magenta")
         (139   0 139 "DarkMagenta")
         (139   0   0 "dark red")
         (139   0   0 "DarkRed")
         (144 238 144 "light green")
         (144 238 144 "LightGreen"))))

;;; (find-rgba :yellowgreen) (find-rgba :fuchsia)

:eof

