;;; -*- Mode: LISP; Syntax: Common-lisp; Package: de.setf.object-graphics.implementation; Base: 10; Lowercase: Yes -*-

<DOCUMENTATION>
 <title>transforming context</title>
 <DESCRIPTION>
  <p>
  defines an abstract class which binds transform for use with implementations which must transform down to 2-d.</p>
  </DESCRIPTION>
 <CHRONOLOGY>
  <DELTA DATE='20030905' AUTHOR='james.anderson@setf.de' />
  <DELTA DATE='20060420' AUTHOR='janderson@ravenpack.com'>
   added optional to spread-optional-coordinates</DELTA>
  </CHRONOLOGY>
 </DOCUMENTATION>

(in-package :de.setf.object-graphics.implementation)

(defparameter *context-view-transform* (matrix-identity (transform-matrix))
  "special binding for the active context's view transform")
(defparameter *context-projection-transform* (matrix-identity (transform-matrix))
  "special binding for the active context's projection transform")
(defparameter *context-transform* (matrix-identity (transform-matrix))
  "special binding for the active context's composite transform")


(defClass transform-context ()
  ((transform
    :initarg :transform :initform nil
    :documentation
    "the view transform is a specifies the coordinate transformation matrix from object coordinate to port coordinates. it combines the projection and ndc transform.")
   (inverse-transform
    :initform nil
    :documentation
    "the view inverse-transform is the inverse of the view transform. it is computed on demand.")
   (projection-transform
    :initarg :projection-transform :initform (transform-identity)
    :reader context-projection-transform)
   (view-transform
    :initarg :view-transform :initform (matrix-identity)
    :reader context-view-transform)
   (inverse-ndc-transform)
   (port-parameters
    :initarg :parameters :initarg :port-parameters :initform nil
    :accessor view-parameters
    :documentation
    "describes the port viewing parameters")))

(def-initialize-clone transform-context
  ;; reuse everything: any changes replace the existing
  (transform
   projection-transform
   view-transform
   port-parameters))

(defMethod context-transform ((context transform-context))
  (with-slots (transform view-transform projection-transform)
              context
    (if transform transform
        (setf transform 
              (matrix-catenate projection-transform view-transform)))))              

(defMethod context-inverse-transform ((context transform-context))
  (with-slots (transform inverse-transform) context
    (or inverse-transform
        (setf inverse-transform
              (matrix-inverse transform (transform-matrix))))))

(defMethod call-with-projection-context
           ((function t) (context transform-context)
            &key
            &allow-other-keys)
  (let* ((*context-view-transform*
          (matrix-copy (context-view-transform context)))
         (*context-projection-transform*
          (matrix-copy (context-projection-transform context)))
         (*context-transform*
          (matrix-copy (context-transform context))))
    (call-next-method)))


;;;
;;; manipulating transforms

(defmacro spread-optional-coordinates_ (x y &optional z)
  `(etypecase ,x
     (number (unless ,y (psetf ,x (point-h ,x)
                               ,y (point-v ,x)
                               ,@(when z `(,z 0)))))
     (location-2 (setf ,@(when z `(,z (location-z ,x)))
                       ,y (location-y ,x)
                       ,x (location-x ,x)))
     (cons (loop (etypecase (first ,x)
                   (number (return))
                   ((and symbol (not null)) (pop ,x))))
           (psetf ,x (pop ,x)
                  ,y (pop ,x)
                  ,@(when z `(,z (pop ,x)))))))


(defun modify-transform (target install op args)
  (ecase op
    (:scale (destructuring-bind (x &optional y z) args
              (spread-optional-coordinates_ x y z)
              (let ((new-m (get-matrix)))
                (with-coerced-variables ((double-float x y z))
                  (with-location-vectors ((delta x y z))
                    (matrix-scale delta target new-m)
                    (funcall install new-m))))))
    (:translate (destructuring-bind (x &optional y z) args
                  (spread-optional-coordinates_ x y z)
                  (let ((new-m (get-matrix)))
                    (with-coerced-variables ((double-float x y z))
                      (with-location-vectors ((delta x y z))
                        (matrix-translate delta target new-m)
                        (funcall install new-m))))))
    (:rotate (destructuring-bind (x &optional y z) args
              (spread-optional-coordinates_ x y z)
               (let ((new-m (get-matrix)))
                 (with-coerced-variables ((double-float x y z))
                   (with-location-vectors ((delta x y z))
                     (matrix-rotate delta target new-m)
                     (funcall install new-m))))))
    (:catenate (destructuring-bind (delta &rest entries) args
                 (declare (dynamic-extent entries))
                 (let ((new-m (get-matrix)))
                   (etypecase delta
                     (number (with-matrices ((delta-m))
                               (apply #'matrix-fill delta-m delta entries)
                               (matrix-catenate target delta-m new-m)))
                     (simple-array (matrix-catenate target delta new-m)))
                   (funcall install new-m))))
    (:set (destructuring-bind (new &rest entries) args
            (declare (dynamic-extent entries))
            (etypecase new
              (number (apply #'matrix-fill target new entries))
              (simple-array (matrix-copy new target)))
            (funcall install target)))
    ((:clear :initialize) (destructuring-bind () args
                            (matrix-initialize target)
                            (funcall install target)))))

:eof

